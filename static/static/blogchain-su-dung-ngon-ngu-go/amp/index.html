<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <title>Blockchain với Golang: Persistence và CLI</title>

    <meta name="description" content="Tiếp tục series Blockchain với Golang, lần này bài viết sẽ hướng dẫn cách lưu data của blockchain vào database và cách tạo một CLI interface cho chương trình." />
    <link rel="canonical" href="../index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="GMO-Z.com Vietnam Lab Center Technology Blog" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Blockchain với Golang: Persistence và CLI" />
    <meta property="og:description" content="Tiếp tục series Blockchain với Golang, lần này bài viết sẽ hướng dẫn cách lưu data của blockchain vào database và cách tạo một CLI interface cho chương trình." />
    <meta property="og:url" content="https://blog.vietnamlab.vn/blogchain-su-dung-ngon-ngu-go/" />
    <meta property="og:image" content="https://drive.google.com/uc?id&#x3D;1j4MN_AgpzlvSjRM3k9loe-71AoX-bxTm&amp;export&#x3D;download" />
    <meta property="article:published_time" content="2018-09-04T01:23:33.000Z" />
    <meta property="article:modified_time" content="2018-09-04T01:23:33.000Z" />
    <meta property="article:tag" content="blockchain" />
    <meta property="article:tag" content="golang" />
    <meta property="article:tag" content="programming" />
    
    <meta property="article:publisher" content="https://www.facebook.com/vietnamlab.vn" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Blockchain với Golang: Persistence và CLI" />
    <meta name="twitter:description" content="Tiếp tục series Blockchain với Golang, lần này bài viết sẽ hướng dẫn cách lưu data của blockchain vào database và cách tạo một CLI interface cho chương trình." />
    <meta name="twitter:url" content="https://blog.vietnamlab.vn/blogchain-su-dung-ngon-ngu-go/" />
    <meta name="twitter:image" content="https://drive.google.com/uc?id&#x3D;1j4MN_AgpzlvSjRM3k9loe-71AoX-bxTm&amp;export&#x3D;download" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="T.M.L" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="blockchain, golang, programming" />
    <meta property="og:image:width" content="1500" />
    <meta property="og:image:height" content="500" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "GMO-Z.com Vietnam Lab Center Technology Blog",
        "url": "https://blog.vietnamlab.vn/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://blog.vietnamlab.vn/favicon.ico",
            "width": 48,
            "height": 48
        }
    },
    "author": {
        "@type": "Person",
        "name": "T.M.L",
        "url": "https://blog.vietnamlab.vn/author/linhtm/",
        "sameAs": []
    },
    "headline": "Blockchain với Golang: Persistence và CLI",
    "url": "https://blog.vietnamlab.vn/blogchain-su-dung-ngon-ngu-go/",
    "datePublished": "2018-09-04T01:23:33.000Z",
    "dateModified": "2018-09-04T01:23:33.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://drive.google.com/uc?id=1j4MN_AgpzlvSjRM3k9loe-71AoX-bxTm&export=download",
        "width": 1500,
        "height": 500
    },
    "keywords": "blockchain, golang, programming",
    "description": "Series lập trình blockchain với Go\n\n 1. Block và blockchain sơ khai\n    [https://blog.vietnamlab.vn/2018/03/19/blockchain-bang-ngon-ngu-go-1st-step-block-va-blockchain-so-khai/]\n 2. Proof of Work\n    [https://blog.vietnamlab.vn/2018/06/29/blockchain-bang-ngon-ngu-go-s/]\n\nLời mở đầu\nQua hai bài viết trước của series, chúng ta đã lập trình được một blockchain đơn\ngiản với khả năng mining để tạo block mới sử dụng thuật toán Proof of Work. Tuy\nnhiên, thông tin tất cả các block vẫn chưa được lưu trữ ",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.vietnamlab.vn/"
    }
}
    </script>

    <meta name="generator" content="Ghost 3.36" />
    <link rel="alternate" type="application/rss+xml" title="GMO-Z.com Vietnam Lab Center Technology Blog" href="../../rss/index.html" />

    <style amp-custom>
    *,
    *::before,
    *::after {
        box-sizing: border-box;
    }

    html {
        overflow-x: hidden;
        overflow-y: scroll;
        font-size: 62.5%;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    body {
        min-height: 100vh;
        margin: 0;
        padding: 0;
        color: #3a4145;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.7rem;
        line-height: 1.55em;
        font-weight: 400;
        font-style: normal;
        background: #fff;
        scroll-behavior: smooth;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    p,
    ul,
    ol,
    li,
    dl,
    dd,
    hr,
    pre,
    form,
    table,
    video,
    figure,
    figcaption,
    blockquote {
        margin: 0;
        padding: 0;
    }

    ul[class],
    ol[class] {
        padding: 0;
        list-style: none;
    }

    img {
        display: block;
        max-width: 100%;
    }

    input,
    button,
    select,
    textarea {
        font: inherit;
        -webkit-appearance: none;
    }

    fieldset {
        margin: 0;
        padding: 0;
        border: 0;
    }

    label {
        display: block;
        font-size: 0.9em;
        font-weight: 700;
    }

    hr {
        position: relative;
        display: block;
        width: 100%;
        height: 1px;
        border: 0;
        border-top: 1px solid currentcolor;
        opacity: 0.1;
    }

    ::selection {
        text-shadow: none;
        background: #cbeafb;
    }

    mark {
        background-color: #fdffb6;
    }

    small {
        font-size: 80%;
    }

    sub,
    sup {
        position: relative;
        font-size: 75%;
        line-height: 0;
        vertical-align: baseline;
    }
    sup {
        top: -0.5em;
    }
    sub {
        bottom: -0.25em;
    }

    ul li + li {
        margin-top: 0.6em;
    }

    a {
        color: #1292EE;
        text-decoration-skip-ink: auto;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 0;
        font-weight: 700;
        color: #121212;
        line-height: 1.4em;
    }

    h1 {
        font-size: 3.4rem;
        line-height: 1.1em;
    }

    h2 {
        font-size: 2.4rem;
        line-height: 1.2em;
    }

    h3 {
        font-size: 1.8rem;
    }

    h4 {
        font-size: 1.7rem;
    }

    h5 {
        font-size: 1.6rem;
    }

    h6 {
        font-size: 1.6rem;
    }

    amp-img {
        height: 100%;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }

    amp-img img {
        object-fit: cover;
    }

    .page-header {
        padding: 50px 5vmin 30px;
        text-align: center;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .page-header a {
        color: #121212;
        font-weight: 700;
        text-decoration: none;
        font-size: 1.6rem;
        letter-spacing: -0.1px;
    }

    .post {
        max-width: 680px;
        margin: 0 auto;
    }

    .post-header {
        margin: 0 5vmin 5vmin;
        text-align: center;
    }

    .post-meta {
        margin: 1rem 0 0 0;
        text-transform: uppercase;
        color: #738a94;
        font-weight: 500;
        font-size: 1.3rem;
    }

    .post-image {
        margin: 0 0 5vmin;
    }

    .post-image img {
        display: block;
        width: 100%;
        height: auto;
    }

    .post-content {
        padding: 0 5vmin;
    }

    .post-content > * + * {
        margin-top: 1.5em;
    }

    .post-content [id]:not(:first-child) {
        margin: 2em 0 0;
    }

    .post-content > [id] + * {
        margin-top: 1rem;
    }

    .post-content [id] + .kg-card,
    .post-content blockquote + .kg-card {
        margin-top: 40px;
    }

    .post-content > ul,
    .post-content > ol,
    .post-content > dl {
        padding-left: 1.9em;
    }

    .post-content hr {
        margin-top: 40px;
    }

    .post .post-content hr + * {
        margin-top: 40px;
    }

    .post-content amp-img {
        background-color: #f8f8f8;
    }

    .post-content blockquote {
        position: relative;
        font-style: italic;
    }

    .post-content blockquote::before {
        content: "";
        position: absolute;
        left: -1.5em;
        top: 0;
        bottom: 0;
        width: 0.3rem;
        background: #000;
    }

    .post-content :not(.kg-card):not([id]) + .kg-card {
        margin-top: 40px;
    }

    .post-content .kg-card + :not(.kg-card) {
        margin-top: 40px;
    }

    .kg-card figcaption {
        padding: 1.5rem 1.5rem 0;
        text-align: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.4em;
        opacity: 0.6;
    }

    .kg-card figcaption strong {
        color: rgba(0,0,0,0.8);
    }

    .post-content :not(pre) code {
        vertical-align: middle;
        padding: 0.15em 0.4em 0.15em;
        border: #e1eaef 1px solid;
        font-weight: 400;
        font-size: 0.9em;
        line-height: 1em;
        color: #dc0050;
        background: #f0f6f9;
        border-radius: 0.25em;
    }

    .post-content > pre {
        overflow: scroll;
        padding: 16px 20px;
        color: #fff;
        background: #1F2428;
        border-radius: 5px;
        box-shadow: 0 2px 6px -2px rgba(0,0,0,.1), 0 0 1px rgba(0,0,0,.4);
    }

    .kg-embed-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    }

    .kg-image-card img {
        margin: auto;
    }

    .kg-gallery-card + .kg-gallery-card {
        margin-top: 0.75em;
    }

    .kg-gallery-container {
        position: relative;
    }

    .kg-gallery-row {
        display: flex;
        flex-direction: row;
        justify-content: center;
    }

    .kg-gallery-image {
        width: 100%;
        height: 100%;
    }

    .kg-gallery-row:not(:first-of-type) {
        margin: 0.75em 0 0 0;
    }

    .kg-gallery-image:not(:first-of-type) {
        margin: 0 0 0 0.75em;
    }

    .kg-bookmark-card,
    .kg-bookmark-publisher {
        position: relative;
    }

    .kg-bookmark-container,
    .kg-bookmark-container:hover {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row-reverse;
        color: currentColor;
        background: rgba(255,255,255,0.6);
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        text-decoration: none;
        border-radius: 5px;
        box-shadow: 0 2px 6px -2px rgba(0, 0, 0, 0.1), 0 0 1px rgba(0, 0, 0, 0.4);
        overflow: hidden;
    }

    .kg-bookmark-content {
        flex-basis: 0;
        flex-grow: 999;
        padding: 20px;
        order: 1;
    }

    .kg-bookmark-title {
        font-weight: 600;
        font-size: 1.5rem;
        line-height: 1.3em;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        max-height: 45px;
        margin: 0.5em 0 0 0;
        font-size: 1.4rem;
        line-height: 1.55em;
        overflow: hidden;
        opacity: 0.8;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    .kg-bookmark-metadata {
        margin-top: 20px;
    }

    .kg-bookmark-metadata {
        display: flex;
        align-items: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.3em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        overflow: hidden;
    }

    .kg-bookmark-metadata amp-img {
        width: 18px;
        height: 18px;
        max-width: 18px;
        max-height: 18px;
        margin-right: 10px;
    }

    .kg-bookmark-thumbnail {
        display: flex;
        flex-basis: 20rem;
        flex-grow: 1;
        justify-content: flex-end;
    }

    .kg-bookmark-thumbnail amp-img {
        max-height: 200px;
    }

    .kg-bookmark-author {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

    .kg-bookmark-publisher::before {
        content: "•";
        margin: 0 .5em;
    }

    .kg-width-full.kg-card-hascaption {
        display: grid;
        grid-template-columns: inherit;
    }

    .post-content table {
        border-collapse: collapse;
        width: 100%;
    }

    .post-content th {
        padding: 0.5em 0.8em;
        text-align: left;
        font-size: .75em;
        text-transform: uppercase;
    }

    .post-content td {
        padding: 0.4em 0.7em;
    }

    .post-content tbody tr:nth-child(2n + 1) {
        background-color: rgba(0,0,0,0.1);
        padding: 1px;
    }

    .post-content tbody tr:nth-child(2n + 2) td:last-child {
        box-shadow:
            inset 1px 0 rgba(0,0,0,0.1),
            inset -1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:nth-child(2n + 2) td {
        box-shadow: inset 1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:last-child {
        border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .page-footer {
        padding: 60px 5vmin;
        margin: 60px auto 0;
        text-align: center;
        background-color: #f8f8f8;
    }

    .page-footer h3 {
        margin: 0.5rem 0 0 0;
    }

    .page-footer p {
        max-width: 500px;
        margin: 1rem auto 1.5rem;
        font-size: 1.7rem;
        line-height: 1.5em;
        color: rgba(0,0,0,0.6)
    }

    .powered {
        display: inline-flex;
        align-items: center;
        margin: 30px 0 0;
        padding: 6px 9px 6px 6px;
        border: rgba(0,0,0,0.1) 1px solid;
        font-size: 12px;
        line-height: 12px;
        letter-spacing: -0.2px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-weight: 500;
        color: #222;
        text-decoration: none;
        background: #fff;
        border-radius: 6px;
    }

    .powered svg {
        height: 16px;
        width: 16px;
        margin: 0 6px 0 0;
    }

    @media (max-width: 600px) {
        body {
            font-size: 1.6rem;
        }
        h1 {
            font-size: 3rem;
        }

        h2 {
            font-size: 2.2rem;
        }
    }

    @media (max-width: 400px) {
        h1 {
            font-size: 2.6rem;
            line-height: 1.15em;
        }
        h2 {
            font-size: 2rem;
            line-height: 1.2em;
        }
        h3 {
            font-size: 1.7rem;
        }
    }
    </style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="page-header">
        <a href="../../index.html">
                GMO-Z.com Vietnam Lab Center Technology Blog
        </a>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">Blogchain bằng ngôn ngữ Go - 3rd Step: Lưu trữ data trên ổ cứng và giao diện CLI</h1>
                <section class="post-meta">
                    T.M.L -
                    <time class="post-date" datetime="2018-09-04">04 Sep 2018</time>
                </section>
            </header>
            <figure class="post-image">
                <amp-img src="https://drive.google.com/uc?id&#x3D;1j4MN_AgpzlvSjRM3k9loe-71AoX-bxTm&amp;export&#x3D;download" width="600" height="340" layout="responsive"></amp-img>
            </figure>
            <section class="post-content">

                <p><em>Series lập trình blockchain với Go</em></p>
<ol>
<li><a href="https://blog.vietnamlab.vn/2018/03/19/blockchain-bang-ngon-ngu-go-1st-step-block-va-blockchain-so-khai/">Block và blockchain sơ khai</a></li>
<li><a href="https://blog.vietnamlab.vn/2018/06/29/blockchain-bang-ngon-ngu-go-s/">Proof of Work</a></li>
</ol>
<h3 id="limu">Lời mở đầu</h3>
<p>Qua hai bài viết trước của series, chúng ta đã lập trình được một blockchain đơn giản với khả năng mining để tạo block mới sử dụng thuật toán Proof of Work. Tuy nhiên, thông tin tất cả các block vẫn chưa được lưu trữ cố định và sẽ biến mất hoàn toàn khi chương trình kết thúc. Chương trình blockchain cũng chưa có một giao diện câu lệnh (CLI) để người dùng có thể tương tác một cách dễ dàng hơn. Trong phần tiếp theo này, chúng ta sẽ add thêm tính năng lưu trữ thông tin blockchain trên hard disk và 1 giao diện câu lệnh (CLI) cho blockchain của chúng ta</p>
<h3 id="lutrdata">Lưu trữ data</h3>
<h4 id="lachndatabasedb">Lựa chọn Database (DB)</h4>
<p>Như đã nói, blockchain của chúng ta hoàn toàn lưu thông tin các block đã đào được trên memory và khi chương trình kết thúc thì tất cả các thông tin này sẽ không được lưu trữ. Một blockchain thật sự cần có data được lưu trữ trên hard disk để có tái sử dụng thông tin các block đã đào được, chia sẻ thông tin với những người sử dụng khác. Với <a href="https://github.com/bitcoin/bitcoin">Bitcoin</a> thì DB được sử dụng là  <a href="https://github.com/google/leveldb">LevelDB</a>, một Key-Value DB viết bằng C++ của Google. Chúng ta cũng sẽ sử dụng 1 Key-Value datatabase, tuy nhiên là một database được viết hoàn toàn bằng Go: <a href="https://github.com/dgraph-io/badger">Badger</a>. Lí do để sử dụng Badger:</p>
<ol>
<li>Được viết hoàn toàn bằng Go, có thể được import vào chương trình 1 cách dễ dàng như một thư viện</li>
<li>Đơn giản, dễ dùng, không cần có DB server để có thể hoạt động</li>
<li>Dù là Key-Value, nhưng đáp ứng đủ nhu cầu cho bài toán của chúng ta ở đây</li>
</ol>
<p>Với Badger thì sẽ không có data type mà cả Key và Value sẽ có định dạng là các mảng <code>byte</code>. Do vậy, để có thể lưu các cấu trúc dữ liệu và đọc lại chúng từ Badger, chúng ta cần phải có công cụ để <code>serialize</code> và <code>deserialize</code> chúng. Ta sẽ dùng thư viện <a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>, một thư viện trong standard library của Go, để giải quyết vấn đề này.</p>
<h4 id="cutrcdliu">Cấu trúc dữ liệu</h4>
<p>Trước khi lập trình các logic code để lưu dữ liệu, chúng ta cần xác định dữ liệu của chúng ta cần lưu gồm có các thông tin gì và sẽ được lưu với cấu trúc như thế nào. Bitcoin hiện tại lưu dữ liệu vào hai phần chính như sau:</p>
<ol>
<li><strong>blocks</strong> lưu trữ metadata mô tả về tất cả các blocks của blockchain</li>
<li><strong>chainstate</strong> lưu trữ trạng thái hiện tại của blockchain, bao gồm tất cả những transaction chưa được xử lý kèm theo một số metadata của chúng</li>
</ol>
<p>Mỗi block sẽ được lưu trữ là một riêng biệt để tối ưu hoá performance. Và khi lưu trữ vào LevelDB thì <strong>blocks</strong> sẽ là những cặp Key - Value như sau:</p>
<ol>
<li><strong>'b' + 32-byte block hash</strong> -&gt; thông tin block index</li>
<li><strong>'f' + 4-byte file number</strong> -&gt; thông tin về file information</li>
<li><strong>'l' -&gt; 4-byte file number</strong> -&gt; Số thứ tự của file block cuối cùng được tạo</li>
<li><strong>'R' -&gt; 1-byte boolean</strong> -&gt; flag thể hiện xem chain có đang được reindex hay không</li>
<li><strong>'F' + 1-byte flag name length + flag name string</strong> -&gt; 1 byte boolean: các thể loại flag có thể mang giá trị on hay of</li>
<li><strong>'t' + 32-byte transaction hash</strong> -&gt; thông tin về transaction index</li>
</ol>
<p>In chainstate, the key -&gt; value pairs are:</p>
<ol>
<li><strong>'c' + 32-byte transaction hash</strong> -&gt; thông tin về unspent transaction output (<a href="https://bitcoin.org/en/glossary/unspent-transaction-output">UTXOS</a> của một transaction</li>
<li><strong>'B' -&gt; 32-byte block hash</strong> -&gt; hash của block, lưu trữ các thông tin unspent transaction output (<a href="https://bitcoin.org/en/glossary/unspent-transaction-output">UTXOS</a> của block này</li>
</ol>
<p>Tuy nhiên, với blockchain đơn giản của chúng ta, do chưa có transactions và tất cả thông tin blocks sẽ được lưu chung vào một file nên chỉ cần 2 cặp Key-Value như sau:</p>
<ol>
<li><strong>32-byte block-hash</strong> -&gt; Structure của block (đã được serialized)</li>
<li><strong>'l'</strong> -&gt; Hash của block mới nhất trong chain</li>
</ol>
<h4 id="serializevdeserialize">Serialize và deserialize</h4>
<p>Do các cặp Key-Value trong Badger đều được lưu dưới dạng <code>[]byte</code> mà chúng ta muốn lưu trữ thông tin block dưới dạng các struct <code>Block</code> vào DB nên ta sẽ sử dụng thư viện <a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a> để thực hiện công việc serialize và deserialize</p>
<p>Đầu tiên là method <code>Serialize</code> cho 1 struct <code>Block</code>.</p>
<pre><code class="language-go">// block.go
// Serialize serialize block to byte data
func (b *Block) Serialize() []byte {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&amp;result)

	err := encoder.Encode(b)

	if err != nil {
		log.Panic(err)
	}

	return result.Bytes()
}
</code></pre>
<p>Code của method khá đơn giản, đầu tiên ta khai báo 1 buffer để lưu thông tin block đã được serialized, sử dụng gob encoder để encode thông tin block, sau đó trả về dưới dạng 1 byte array.</p>
<p>Tiếp theo là function <code>DeserializeBlock</code>, tuy nhiên đây sẽ không phải là method cho một struct <code>Block</code> mà là 1 function riêng</p>
<pre><code class="language-go">// block.go
// DeserializeBlock deserialize block from byte data
func DeserializeBlock(d []byte) *Block {
	var block Block

	decoder := gob.NewDecoder(bytes.NewReader(d))
	err := decoder.Decode(&amp;block)

	if err != nil {
		log.Panic(err)
	}

	return &amp;block
}
</code></pre>
<h4 id="lutrdata">Lưu trữ Data</h4>
<p>Trước tiên, ta phải thêm Badger vào dependencies vào project blockchain của chúng ta:</p>
<pre><code class="language-sh">$ dep ensure -add github.com/dgraph-io/badger
</code></pre>
<p>Sau đó, trong code, badger có thể được import và sử dụng như các thư viện standard khác của Go</p>
<pre><code class="language-go">import (
	"log"

	"github.com/dgraph-io/badger"
)
</code></pre>
<p>Ta cũng tạo một file mới <code>db_util.go</code> chứa các function liên quan đến xử lý DB. Đầu tiên là function để khởi tạo một instance của Badger:</p>
<pre><code class="language-go">/ InitDB create database instance
func InitDB(dbDir string) *badger.DB {
	opts := badger.DefaultOptions
	var dbRootPath string

	if runtime.GOOS == "windows" {
		dbRootPath = "C:/tmp"
	} else {
		dbRootPath = "/tmp"
	}

	dbPath := filepath.FromSlash(dbRootPath + "/" + dbDir)
	opts.ValueDir = dbPath
	opts.Dir = dbPath
	db, err := badger.Open(opts)

	if err != nil {
		log.Panic(err)
	}

	return db
}
</code></pre>
<p>Function này chỉ đơn giản là khởi tạo một instance Badger với thiết lập địa chỉ lưu trữ database được lấy từ tham số của hàm.</p>
<p>Để sử dụng Badger trong code của Blockchain của chúng ta, trước mắt chúng ta khai báo 2 biến constant, một là folder chứa data và một là prefix cho tất cả các Key của dữ liệu của chúng ta.</p>
<pre><code class="language-go">// blockchain.go
const dbDirectory = "gochain"
const dbPrefix = "gc_"
</code></pre>
<p>Việc tiếp theo là  sửa lại function <code>NewBlockchain</code> trong file <code>blockchain.go</code>. Về mặt logic, function này phải làm được những bước sau:</p>
<ul>
<li>Tạo một instance DB</li>
<li>Kiểm tra xem đã có thông tin blockchain trong chưa?</li>
<li>Nếu đã có thông tin blockchain:
<ol>
<li>Tạo mới 1 <code>Blockchain</code> instance.</li>
<li>Thiết lập để tip của <code>Blockchain</code> instance này trỏ đến hash của block mới nhất được lưu trong DB.</li>
</ol>
</li>
<li>Nếu không có thông tin blockchain:
<ol>
<li>Tạo block genesis.</li>
<li>Lưu block trong DB.</li>
<li>Lưu hash của genesis block trong DB với vai trò là hash của block mới nhất.</li>
<li>Tạo mới 1 <code>Blockchain</code> instance với tip trỏ trến block genesis.</li>
</ol>
</li>
</ul>
<p>Nếu thể hiện bằng code thì sẽ như sau:</p>
<pre><code class="language-go">// blockchain.go
// NewBlockchain initiate a new chain
func NewBlockchain() *Blockchain {
	db := InitDB(dbDirectory)
	isDataExist := CheckPrefixExist(dbPrefix, db)

	var tip []byte
	err := db.Update(func(txn *badger.Txn) error {
		if isDataExist {
			item, err := txn.Get([]byte(dbPrefix + "l"))
			if err != nil {
				return err
			}

			tip, err = item.Value()

			if err != nil {
				return err
			}
		} else {
			genesis := NewGenesisBlock()
			err := txn.Set(append([]byte(dbPrefix), genesis.Hash...), genesis.Serialize())
			if err != nil {
				return err
			}

			err = txn.Set([]byte(dbPrefix+"l"), genesis.Hash)
			if err != nil {
				return err
			}

			tip = genesis.Hash
		}

		return nil
	})

	if (err != nil) {
		log.Panic(err)
	}

	return &amp;Blockchain{tip, db}
}
</code></pre>
<p>Với Badger thì tất cả các xử lý với DB phải được thực hiện trong một transaction, với đoạn code ở trên thì ta đã sử dụng một transaction Read-Update của Badger:</p>
<pre><code class="language-go">err := db.Update(func(txn *badger.Txn) error {
...
}
</code></pre>
<p>Trong body của transaction Read-Update này ta có thể thực hiện các thao tác đọc và ghi dữ liệu dưới dạng Key-Value. Có thể thấy là với mỗi lần đọc ghi, ta đều gán thêm <code>dbPrefix</code> vào phía trước của Key:</p>
<pre><code class="language-go">item, err := txn.Get([]byte(dbPrefix + "l"))
...
err := txn.Set(append([]byte(dbPrefix), genesis.Hash...), 
...
</code></pre>
<p>Function <code>CheckPrefixExist</code> dùng để check xem có dữ liệu blockchain hay chưa được implement ở trong file <code>db_util</code> như sau</p>
<pre><code class="language-go">// db_util.go
// CheckPrefixExist check if there is data for this prefix in the database
func CheckPrefixExist(prefix string, db *badger.DB) bool {
	var isPrefixExist bool
	err := db.View(func(txn *badger.Txn) error {
		opts := badger.DefaultIteratorOptions
		opts.PrefetchValues = false // Vì chỉ cần check key nên ta chỉ get key, không lấy giá trị value nhằm tăng performance
		it := txn.NewIterator(opts) // Tạo 1 Iterator mới
		defer it.Close()
		prefix := []byte(dbPrefix)

        // Check lần lượt xem có key nào có prefix ứng với prefix đã truyền vào không, nếu có thì break
		for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
			isPrefixExist = true
			break
		}

		return nil
	})

	if (err != nil) {
		log.Panic(err)
	}

	return isPrefixExist
}
</code></pre>
<p>Vì ở đây chỉ cần đọc dữ liệu nên ta sử dụng transaction Read Only của Badger</p>
<pre><code class="language-go">err := db.View(func(txn *badger.Txn) error {
...
})
</code></pre>
<p>Ngoài ra, để check xem liệu trong DB đã tồn tại Key có prefix như prefix đã định chưa thì ta sử dụng tính năng Iterator của Badger để duyệt lần lượt các key trong DB.</p>
<p>Quay lại đoạn code của <code>NewBlockchain</code> ta thấy cách khởi tạo 1 <code>Blockchain</code> instance cũng đã có thay đổi:</p>
<pre><code class="language-go">return &amp;Blockchain{tip, db}
</code></pre>
<p>Chúng ta không lưu toàn bộ thông tin blocks vào một trường của struct nữa mà chỉ lưu hash của block mới nhất (tip). Ngoài ra, một DB connection cũng được lưu, trong khi chương trình đang chạy, connection này sẽ luôn được mở và đi kèm với <code>Blockchain</code> instance. ```Blockchain`` struct hiện tại sẽ trở thành như sau:</p>
<pre><code class="language-go">type Blockchain struct {
	tip []byte
	db  *badger.DB
}
</code></pre>
<p>Tiếp theo, chúng ta cũng phải sửa <code>AddBlock</code> method, một block mới sẽ được lưu vào DB thay vì chỉ là add 1 phần tử vào array như trước:</p>
<pre><code class="language-go">// blockchain.go
// AddBlock add new block
func (bc *Blockchain) AddBlock(data string) {
	var lastHash []byte

	err := bc.db.View(func(txn *badger.Txn) error {
		item, err := txn.Get([]byte(dbPrefix + "l"))
		if err != nil {
			log.Panic(err)
		}

		lastHash, err = item.Value()

		if err != nil {
			return err
		}

		return nil
	})

	newBlock := NewBlock(data, lastHash)

	err = bc.db.Update(func(txn *badger.Txn) error {
		err = txn.Set(append([]byte(dbPrefix), newBlock.Hash...), newBlock.Serialize())
		if err != nil {
			return err
		}

		err = txn.Set([]byte(dbPrefix + "l"), newBlock.Hash)
		if err != nil {
			return err
		}

		bc.tip = newBlock.Hash

		return nil
	})
}
</code></pre>
<p>Ta sẽ đọc hash của block mới nhất từ DB, sau đó, dùng hash này để tạo một block mới (mining), sau đó serialize thông tin của block mới, lưu vào DB. Ta cũng update giá trị của Key <code>dbPrefix + "l"</code> là hash của block mới này và thiết lập tip của instance <code>Blockchain</code> là hash này.</p>
<p>Sau vài đoạn code dài, vậy là chúng ta đã hoàn thành việc thay đổi cơ chế lưu dữ liệu của blockchain từ tạm thời (array trên bộ nhớ) sang lưu trên 1 DB trên hard disk. Tiếp theo sẽ là việc đọc thông tin ra như thế nào.</p>
<h4 id="cthngtincablockchain">Đọc thông tin của blockchain</h4>
<p>Toàn bộ các blocks của chain đã được lưu trên DB, nên dù khi ta có dừng chương trình và sau đó chạy lại ta vẫn có thể mở lại kết nối với blockchain đã lưu và add thêm block mới được. Tuy nhiên, vì không phải làm một array nữa, nên ta sẽ không dễ dàng in toàn bộ các blocks chain ra được nữa.</p>
<p>Badger có cung cấp các Iterator method để ta có duyệt các cặp Key-Value được lưu trong DB, tuy nhiên chúng sẽ duyệt theo thứ tự giá trị của các Key chứ không theo thứ tự data được lưu vào. Do vậy, chúng ta sẽ tự lập trình 1 Iterator để có thể duyệt thông tin block theo thứ tự được add vào. Dưới đây là struct <code>BlockchainIterator</code> ta sẽ dùng để làm công việc duyệt block:</p>
<pre><code>// blockchain.go
type BlockchainIterator struct {
	currentHash []byte
	db          *badger.DB
}
</code></pre>
<p>Mỗi lần ta muốn duyệt blocks trong blockchain, ta sẽ tạo instance <code>BlockchainIterator</code> như trên và instance này sẽ lưu hash của block hiện tại và 1 kết nối tới DB. Do đó, 1 Iterator sẽ luôn đi kèm với 1 blockchain và sẽ được tạo bởi 1 method của <code>Blockchain</code>:</p>
<pre><code class="language-go">// blockchain.go
// Iterator create an iterator for a blockchain instance
func (bc *Blockchain) Iterator() *BlockchainIterator {
	bci := &amp;BlockchainIterator{bc.tip, bc.db}
	return bci
}
</code></pre>
<p>Vì 1 Iterator ban đầu sẽ trở đến tip một blockchain, nên blocks sẽ được duyệt từ mới nhất đến cũ nhất. Tiếp theo, ta sẽ tạo method <code>Next</code> cho <code>BlockchainIterator</code>, method trả về block trước đó của block hiện tại trong blockchain</p>
<pre><code class="language-go">// blockchain.go
// Next iterate to next element
func (i *BlockchainIterator) Next() *Block {
	var block *Block

	err := i.db.View(func(txn *badger.Txn) error {
		item, err := txn.Get(append([]byte(dbPrefix), i.currentHash...))
		if err != nil {
			return err
		}

		encodedBlock, err := item.Value()

		if err != nil {
			return err
		}

		block = DeserializeBlock(encodedBlock)
		return nil
	})

	if err != nil {
		log.Panic(err)
	}

	i.currentHash = block.PrevBlockHash
	return block
}
</code></pre>
<p>Khi này, đoạn code để hiển thị thông tin toàn bộ blocks sẽ trở thành như sau:</p>
<pre><code class="language-go">bc := NewBlockchain()
bci := bc.Iterator()

for {
	block := bci.Next()

	fmt.Printf("Prev block's hash: %x\n", block.PrevBlockHash)
	fmt.Printf("Current block's hash: %x\n", block.Hash)
	fmt.Printf("Current block's data: %s\n", block.Data)

	pow := InitProofOfWork(block)
	fmt.Printf("PoW: %s\n", strconv.FormatBool(pow.Validate()))
	fmt.Println()

	if len(block.PrevBlockHash) == 0 {
		break
	}
}
</code></pre>
<p>Vậy là các tính năng cơ bản với DB cho blockchain đơn giản của chúng ta đã được hoàn thành xong! Tiếp theo sẽ là giao diện CLI</p>
<h3 id="cliinterface">CLI Interface</h3>
<p>Từ trước đến giờ, chương trình của chúng ta chưa hỗ trợ việc tương tác với chương trình, các thao tác đều được hard-coded vào thẳng chương trình. Ta sẽ lập trình giao diện CLI, để người dùng có thể add block mới và xem toàn bộ thông tin các blocks từ command line.</p>
<p>Ta có thể sử dụng standard library của Go để thực hiện các tính năng này, tuy nhiên để việc lập trình được nhanh và dễ dàng hơn ta sẽ sử dụng thư viện <a href="https://github.com/urfave/cli">urfave/cli</a>.</p>
<pre><code class="language-sh">$ dep ensure -add github.com/urfave/cli
</code></pre>
<p>Và import nó ở trong file main</p>
<pre><code class="language-go">// main.go
import (
	"fmt"
	"log"
	"os"
	"strconv"

	"github.com/urfave/cli"
)
</code></pre>
<p>Sử dụng thư viện này cũng khá đơn giản, hàm <code>main</code> của chúng ta sẽ trở thành như sau:</p>
<pre><code class="language-go">// main.go
func main() {
	app := cli.NewApp()

	bc := NewBlockchain()
	defer bc.db.Close()

	app.Commands = []cli.Command{
		{
			Name:    "addblock",
			Aliases: []string{"ab"},
			Usage:   "add a new block to the chain",
			Flags: []cli.Flag{
				cli.StringFlag{
					Name:  "data, d",
					Usage: "data for the new block",
				},
			},
			Action: func(c *cli.Context) error {
				blockData := c.String("data")

				if blockData == "" {
					cli.ShowCommandHelpAndExit(c, "addblock", 1)
				}
				bc.AddBlock(blockData)

				return nil
			},
		},
		{
			Name:    "printchain",
			Aliases: []string{"p"},
			Usage:   "add a new block to the chain",
			Action: func(c *cli.Context) error {
				bci := bc.Iterator()

				for {
					block := bci.Next()
                    ...
					if len(block.PrevBlockHash) == 0 {
						break
					}
				}

				return nil
			},
		},
    }

	err := app.Run(os.Args)
	if err != nil {
		log.Panic(err)
	}
}
</code></pre>
<p>Sử dụng <code>urfave/cli</code>, ta tạo entry point cho chương trình của mình:</p>
<pre><code class="language-go">// main.go
app := cli.NewApp()
</code></pre>
<p>Sau đó, add các command mà ta muốn chương trình hỗ trợ vào entry point này. Mỗi command sẽ là 1 instance của struct <code>cli.Command</code>. Vì chương trình sẽ có 2 command là tạo block mới và xem tất cả các block đã có nên list commands truyền vào sẽ có 2 phần tử như đoạn code ở dưới. Mỗi command này sẽ thực hiện đoạn code trong anonymous function được gán vào trường <code>Action</code> của struct <code>cli.Command</code>. Ngoài ra với command <code>addblock</code> thì cần phải truyền data của block mới vào cho chương trình nên ta cần định nghĩa thêm 1 flag riêng để có thể thực hiện việc này bằng cách sử dụng trường <code>Flags</code>. Bạn đọc có thể tham khảo thêm ý nghĩa các trường khác và cách dùng ở trong tài liệu của <code>urfave/cli</code>.</p>
<pre><code class="language-go">app.Commands = []cli.Command{
	{
		Name:    "addblock",
        Flags: ...
        Action: func(c *cli.Context) error {
            ...
        }
	},
	{
		Name:    "printchain",
		...
        Action:  func(c *cli.Context) error {
            ...
        }
	},
}
</code></pre>
<p>Bây giờ, ta sẽ thử chạy chương trình lần đầu tiên với không 1 command nào được truyền vào.</p>
<pre><code>$ ./gochain                                                                                                                      
NAME:
   Gochain - A blockchain in Golang

USAGE:
   gochain [global options] command [command options] [arguments...]

VERSION:
   0.0.0

DESCRIPTION:
   A blockchain in Golang

COMMANDS:
     addblock, ab   add a new block to the chain
     printchain, p  print all blocks in the chain
     help, h        Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --help, -h     show help
   --version, -v  print the version
</code></pre>
<p>Ta có thể thấy khi chạy lần đầu tiên, genesis block sẽ được đào và add vào blockchain và khi không có command nào được truyền vào, nhờ thư viên <code>urfave/cli</code> ta có một giao diện hướng dẫn rất đẹp và trực quan.</p>
<p>Tiếp theo thử add một block mới vào blockchain xem sao</p>
<pre><code>$ ./gochain addblock -d "Linh Dep Trai"                                                                                          
Mining the block containing "Linh Dep Trai"
0000a37bd73cf8687a03f9df39b7d4b2dde7d8cb7d409428fc48b6ff8d53c0ed


Done adding new block to chain!
$./gochain addblock -d "Linh Dep Trai 2"                                                                                        
Mining the block containing "Linh Dep Trai 2"
0000f2db38fddfbb37f4819a2bf8fd013f31c55dcb413365ca3c1327ea8b1ad2


Done adding new block to chain!⏎
</code></pre>
<p>Ta có thể xem lại thông tin của các blocks vừa được add bằng command <code>printchain</code></p>
<pre><code>$ ./gochain printchain                                                                                                           
Prev block's hash: 0000a37bd73cf8687a03f9df39b7d4b2dde7d8cb7d409428fc48b6ff8d53c0ed
Current block's hash: 0000f2db38fddfbb37f4819a2bf8fd013f31c55dcb413365ca3c1327ea8b1ad2
Current block's data: Linh Dep Trai 2
PoW: true

Prev block's hash: 0000fc08f8dd06ab30990f649bcd8ebf9bd3ad4bc44c8716b98cff59e757ac09
Current block's hash: 0000a37bd73cf8687a03f9df39b7d4b2dde7d8cb7d409428fc48b6ff8d53c0ed
Current block's data: Linh Dep Trai
PoW: true

Prev block's hash:
Current block's hash: 0000fc08f8dd06ab30990f649bcd8ebf9bd3ad4bc44c8716b98cff59e757ac09
Current block's data: Genesis Block
PoW: true
</code></pre>
<p>Data của blockchain đã được lưu tại folder <code>/tmp/gochain</code> như trong setting khi khởi tạo Badger:</p>
<pre><code>$ ls /tmp/gochain/                                                  
000000.vlog 000006.sst  MANIFEST
</code></pre>
<h3 id="ktlun">Kết luận</h3>
<p>Kết thúc phần này, chương trình blockchain của chúng ta đã có một giao diện CLI khá ổn với data được lưu trữ trên hard disk, có thể được ghi và đọc lại nhiều lần giữa các lần chạy. Phần tiếp theo chúng ta sẽ add thêm chức năng xử lý transaction, tính năng quan trọng của một blockchain hoàn chỉnh.</p>
<h3 id="thamkho">Tham khảo</h3>
<ul>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-3/">https://jeiwan.cc/posts/building-blockchain-in-go-part-3/</a></li>
<li><a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage">https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage</a></li>
<li><a href="https://github.com/urfave/cli">https://github.com/urfave/cli</a></li>
<li><a href="https://github.com/dgraph-io/badger">https://github.com/dgraph-io/badger</a></li>
</ul>


            </section>

        </article>
    </main>
    <footer class="page-footer">
        <h3>GMO-Z.com Vietnam Lab Center Technology Blog</h3>
            <p>Blog chia sẻ kỹ thuật của thành viên công ty GMO-Z.com Vietnam Lab Center</p>
        <p><a href="../../index.html">Read more posts →</a></p>
        <a class="powered" href="https://ghost.org" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 156 156"><g fill="none" fill-rule="evenodd"><rect fill="#15212B" width="156" height="156" rx="27"/><g transform="translate(36 36)" fill="#F6F8FA"><path d="M0 71.007A4.004 4.004 0 014 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0130 84H4a4 4 0 01-4-4.007v-8.986zM50 71.007A4.004 4.004 0 0154 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0180 84H54a4 4 0 01-4-4.007v-8.986z"/><rect y="34" width="84" height="17" rx="4"/><path d="M0 4.007A4.007 4.007 0 014.007 0h41.986A4.003 4.003 0 0150 4.007v8.986A4.007 4.007 0 0145.993 17H4.007A4.003 4.003 0 010 12.993V4.007z"/><rect x="67" width="17" height="17" rx="4"/></g></g></svg> Published with Ghost</a>
    </footer>
    
</body>
</html>
