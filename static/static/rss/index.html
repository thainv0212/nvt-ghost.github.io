<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[GMO-Z.com Vietnam Lab Center Technology Blog]]></title><description><![CDATA[Blog chia sẻ kỹ thuật của thành viên công ty GMO-Z.com Vietnam Lab Center]]></description><link>https://blog.vietnamlab.vn/</link><image><url>https://blog.vietnamlab.vn/favicon.png</url><title>GMO-Z.com Vietnam Lab Center Technology Blog</title><link>https://blog.vietnamlab.vn/</link></image><generator>Ghost 3.36</generator><lastBuildDate>Wed, 23 Dec 2020 15:53:02 GMT</lastBuildDate><atom:link href="https://blog.vietnamlab.vn/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Báo cáo nghiên cứu quý 3 năm 2020]]></title><description><![CDATA[<p>Một năm trôi qua thật nhanh, thế là đã kết thúc 3/4 chặng đường năm 2020. Như thường lệ, cuối tháng 9 vừa qua, công ty TNHH GMO-Z.com Việt Nam Lab Center( VNLab) chúng tôi đã tổ chức buổi báo cáo nghiên cứu của quý 3. Hãy theo</p>]]></description><link>https://blog.vietnamlab.vn/bao-cao-nghien-cuu-quy-3/</link><guid isPermaLink="false">5f89090b2e038c0001cdcaa0</guid><category><![CDATA[news]]></category><category><![CDATA[vnlab]]></category><category><![CDATA[2020]]></category><category><![CDATA[báo cáo]]></category><category><![CDATA[Tin tức]]></category><dc:creator><![CDATA[V.H.V]]></dc:creator><pubDate>Fri, 30 Oct 2020 02:57:00 GMT</pubDate><media:content url="https://blog.vietnamlab.vn/content/images/1CSKMZA-hwBOtsfRK0JjjcNZUrF80lGLt.PNG" medium="image"/><content:encoded><![CDATA[<img src="https://blog.vietnamlab.vn/content/images/1CSKMZA-hwBOtsfRK0JjjcNZUrF80lGLt.PNG" alt="Báo cáo nghiên cứu quý 3 năm 2020"><p>Một năm trôi qua thật nhanh, thế là đã kết thúc 3/4 chặng đường năm 2020. Như thường lệ, cuối tháng 9 vừa qua, công ty TNHH GMO-Z.com Việt Nam Lab Center( VNLab) chúng tôi đã tổ chức buổi báo cáo nghiên cứu của quý 3. Hãy theo dõi tiếp bài viết của tôi để biết trong quý vừa rồi các kỹ sư đã nghiên cứu những nội dung gì nhé.</p><p>    Quý vừa qua, có 5 nhóm kỹ sư tham gia nghiên cứu, với nội dung chính như sau:</p><!--kg-card-begin: markdown--><h3 id="topic1biphtbiunghincucnidungvlthuytvimplementqlearningtrongreinforcementlearningcakshm">Topic 1: Bài phát biểu nghiên cứu có nội dung về: Lý thuyết và implement Q-Learning trong Reinforcement Learning của kỹ sư H.M.Đ</h3>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1pBEIfAdrvod80Hh31jxtmJcvbzTOlMGa.JPG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Chi tiết của bài nghiên cứu xoay quanh 3 nội dung sau:</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1E-osUOUFN9ShVpgPZnWhw4oNn13hqWGf&amp;export=download" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Học tăng cường (Reinforcement Learning-RL) là một trong ba kiểu học máy chính bên cạnh học giám sát (Supervised Learning) và học không giám sát (Unsupervised Learning). Bản chất của RL là trial-and-error, nghĩa là thử đi thử lại và rút ra kinh nghiệm sau mỗi lần thử như vậy. Gần đây, RL đã đạt được những thành tựu đáng kể khi các thuật toán của DeepMind (AlphaGo, AlphaZero, AlphaStar,...) đã chiến thắng áp đảo các tuyển thủ thế giới trong những trò chơi mà con người đã từng nghĩ rằng máy móc sẽ không bao giờ có thể vượt mặt như cờ vây hay StarCraft.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1eDqnY85ONXRIc6wXtEu_AUO88lwBJELn&amp;export=download" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p></p><!--kg-card-begin: markdown--><h3 id="topic2biphtbiunghincucnidungvgametesttingnhtbinhm3ksdthllthk">Topic 2: Bài phát biểu nghiên cứu có nội dung về Game test tiếng Nhật bởi nhóm  3 kỹ sư  D.T.H.L, L.T.Đ, H.Đ.K.</h3>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1qSxmOUqou4_GytUVuJ8zrAkvI76Gq25F.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Chi tiết của bài nghiên cứu xoay quanh 3 nội dung sau:</p><ul><li>Chức năng thêm.</li><li>Hướng cải thiện- kỹ thuật</li><li>Hướng cải thiện- giao diện</li></ul><!--kg-card-begin: markdown--><h3 id="topic3biphtbiunghincucnidungvngdngxydnghthnggibivitphhpvimingicchomediacanhm4kspvtttnvttht">Topic 3: Bài phát biểu nghiên cứu có nội dung về Ứng dụng xây dựng hệ thống gợi ý bài viết phù hợp với mỗi người đọc cho media của nhóm 4 kỹ sư P.V.Đ, T.T.T, N.V.T, T.H.T.</h3>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1oiuJF9mbgf8Kt75qiRpF_KER2hMR4e4W.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Chi tiết của bài nghiên cứu xoay quanh 4 nội dung:</p><ul><li>REM beta2</li><li>Content-Based Recommendation</li><li>Admin Page</li><li>Kế hoạch phát triển</li></ul><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1YYUkPLbLlFZWZ6qe00fc-3SP5549JQMU.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><!--kg-card-begin: markdown--><h3 id="topic4biphtbiunghincucnidungvhthngchmcngbngnhndinkhunmtcanhm3kslmltphpvh">Topic 4: Bài phát biểu nghiên cứu có nội dung về hệ thống chấm công bằng nhận diện khuôn mặt của nhóm 3 kỹ sư: L.M.L, T.P.H, P.V.H.</h3>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/11bzSUByr84rQ2dV2g6ohLBFf7DG3Jav1.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Chi tiết của bài nghiên cứu xoay quanh các nội dung:</p><ul><li>Các vấn đề trong quý trước</li><li>Xử lý lại dữ liệu</li><li>Lưu ảnh đánh giá nhận diện khuôn mặt</li><li>Triển khai chi nhánh Hà Nội</li><li>Tìm hiểu lại source code</li><li>Thử nghiệm triển khai với dữ liệu khoảng 1000 người</li><li>Thử nghiệm mô hình arcface</li><li>Thử nghiệm chạy multi-thread và multi-process</li><li>Tìm hiểu và thử nghiệm anti spoofing</li></ul><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1fzq383GP4jLAvOwo5NXaKbb5gH_XUIvt.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><!--kg-card-begin: markdown--><h3 id="topic5biphtbiunghincucnidungvquestionnaireservicecakshht">Topic 5: Bài phát biểu nghiên cứu có nội dung về Questionnaire service của kỹ sư H.H.T.</h3>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/180FCCk6njb7TnCRX3V4eBk1SXLs5lwJX.JPG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>Chi tiết của bài nghiên cứu xoay quanh các nội dung:</p><ul><li>Giới thiệu tổng quan.</li><li>Thiết kế sơ lược.</li><li>Cách thu hút client và thu thập được data tốt.</li><li>Giới thiệu Công nghệ.</li><li>Những chức năng mở rộng và nâng cao</li><li>Đối  tượng khách hàng</li><li>Hình thức thu tiền</li></ul><figure class="kg-card kg-image-card"><img src="https://blog.vietnamlab.vn/content/images/1ULAb3xLuLCAj6MhH5giKgVhTPO-NIXv7.PNG" class="kg-image" alt="Báo cáo nghiên cứu quý 3 năm 2020"></figure><p>  Chỉ còn hơn 2 tháng nữa là hết năm 2020, đã đến lúc chúng ta nạp năng lượng để chạy cho quãng đường nước rút. Năm nay là 1 năm đầy biến động với tất cả chúng ta nhưng ngọn lửa tình yêu công nghệ, đam mê học hỏi, nghiên cứu trong các kỹ sư của chúng tôi vẫn cháy bỏng hơn bao giờ hết. Hãy gia nhập gia đình Vnlab chúng tôi để cùng yêu, cùng cháy hết mình với công nghệ và tạo ra những sản phẩm của riêng mình nhé.</p><p></p><p></p><p></p>]]></content:encoded></item><item><title><![CDATA[Phân lớp (Layering) trong kiến trúc mạng Internet]]></title><description><![CDATA[<!--kg-card-begin: markdown--><p>Layering là chính là phân lớp trong kiến trúc mạng internet, nó mô phân chia chi tiết vai trò và nhiệm vụ của từng lớp qua đó giúp cho các kiến trúc sư hệ thống thiết kế mô hình mạng một cách tối ưu và bảo mật hơn. Kiến thức</p>]]></description><link>https://blog.vietnamlab.vn/pha/</link><guid isPermaLink="false">5f71b1932e038c0001cdca74</guid><dc:creator><![CDATA[T.C.Q]]></dc:creator><pubDate>Sat, 10 Oct 2020 00:01:23 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1XFaezXoUQos7l2x036dK2uxHqNJGTrTU&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://drive.google.com/uc?id=1XFaezXoUQos7l2x036dK2uxHqNJGTrTU&export=download" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"><p>Layering là chính là phân lớp trong kiến trúc mạng internet, nó mô phân chia chi tiết vai trò và nhiệm vụ của từng lớp qua đó giúp cho các kiến trúc sư hệ thống thiết kế mô hình mạng một cách tối ưu và bảo mật hơn. Kiến thức trong bài viết này rất cơ bản nhưng rất cần thiết đối với những bạn có mục tiêu trở thành kiến trúc sư hệ thống mạng và chuyên viên bảo mật hệ thống.</p>
<p><strong>1. Layer là gì?</strong></p>
<p>Đầu tiên hãy nhìn lại sự hoạt động của 7 layer ở tầng network. Các layer này có nhiệm vụ khác nhau và có liên kết với nhau một cách chặt chẽ với nhau</p>
<p><img src="https://drive.google.com/uc?id=1ywshz_hQE2ap_R84sUe1_bBS35xdD_qy&amp;export=download" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"></p>
<ul>
<li><span style="font-weight: 400;">Là một trong những kỹ thuật chung nhất để giải quyết vấn đề phức tạp của hệ thống phần mềm</span></li>
<li><span style="font-weight: 400;">Dùng để xử lý một phần hệ thống phức tạp</span></li>
<li><span style="font-weight: 400;">Nguyên lý subsystem trong phần mềm được sắp xếp như trong một vài form của layer cake</span></li>
<li><span style="font-weight: 400;">Higher layer dùng những service khác nhau được định nghĩa bởi lower layer, nhưng không thể nào dùng service của lớp dưới lower layer của nó.</span></li>
<li><span style="font-weight: 400;">Phần khó nhất của một kiến trúc layer là quyết định layer nào có và trách nhiệm của mỗi layer là gì.</span></li>
</ul>
<p><strong>1.1 Lợi ích của layer</strong></p>
<ul>
<li><span style="font-weight: 400;">Có thể hiểu rõ một lớp đơn mà không cần biết nhiều về lớp khác.</span></li>
<li><span style="font-weight: 400;">Có thể thay thế các layer bằng việc sửa đổi những thực thi của những service cơ bản giống nhau.  Vi dụ:</span><span style="font-weight: 400;"> FTP service có thể chạy mà không cần thay đổi ethernet, PPP, hay  cable mạng.</span></li>
<li><span style="font-weight: 400;">Tối thiểu hóa sự phụ thuộc giữa các layers. </span><span style="font-weight: 400;">Nếu cable mạng thay đổi hệ thống vật lý, việc cung cấp IP sẽ vẫn làm việc mà không phải thay đổi FTP service</span></li>
<li><span style="font-weight: 400;">Layer tạo ra một chuẩn tốt. Ví dụ: </span><span style="font-weight: 400;">TCP và IP là chuẩn bởi vì nó định nghĩa những layer của nó nên hoặt động như thế nào.</span></li>
<li><span style="font-weight: 400;">Tái sử dụng:</span><br>
<span style="font-weight: 400;">          Xây dựng layer một lần có thể sử dụng cho nhiều service ở cập độ cao hơn.</span><br>
<span style="font-weight: 400;">          Thay vì TCP/IP được dùng bởi FTP, telnet, ssh, và HTTP</span></li>
</ul>
<p><strong>1.2 Hạn chế của layer</strong></p>
<ul>
<li><span style="font-weight: 400;">Layers đóng gói ở một vài chỗ nhưng không phải tất cả đều tốt. Đôi khi có một lần thay đổi thì sẽ thế nào:</span><br>
<span style="font-weight: 400;">           </span><span style="font-weight: 400;">Ví dụ: Trong một layer của ứng dụng enterprise mà thêm một trường để hiển thị trên UI, phải thêm vào DB và tất cả các layer ở giữa.</span></li>
<li><span style="font-weight: 400;">Extra layers có thể ảnh hưởng tới performance</span><br>
<span style="font-weight: 400;">           Vì nó phải transform từ một cái này tới cái khác. Tuy nhiên việc đóng gói của một chức năng cơ bản thường cho hiệu quả hơn.</span><br>
<span style="font-weight: 400;">           Một layer đơn control một transaction thì sẽ hiệu quả và sẽ làm tất cả mọi thứ nhanh hơn</span></li>
</ul>
<p><strong>2. The Evolution of Layers in Enterprise Applications</strong></p>
<p><img src="https://drive.google.com/uc?id=1trr-gmtE0xkCTC1-soobgER3gi2dl7Xq&amp;export=download" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"></p>
<p><span style="font-weight: 400;"> 2.1 Ban đầu khi chạy batch system:</span><br>
<span style="font-weight: 400;">     No layers</span><br>
<span style="font-weight: 400;"> 2.2 Thập kỷ 90 với sự phát triển của client-server systems:</span><br>
<span style="font-weight: 400;">     2-layer systems:</span><br>
<span style="font-weight: 400;">     + Client nắm giữ UI và application code khác</span><br>
<span style="font-weight: 400;">     + Server thường chỉ liên quan tới DB</span><br>
<span style="font-weight: 400;">     + Hạn chế:</span><br>
<span style="font-weight: 400;">        ++ Nhúng logic vào màn hình =&gt; dễ dupplicate code</span><br>
<span style="font-weight: 400;">        ++ domain logic phức tạp thì rất khó code</span><br>
<span style="font-weight: 400;">        ++ Thay thế domain logic xử lý ở DB như stored procedures =&gt; vẫn bị giới hạn với kiến trúc cơ học cũng như dễ xảy ra nhiều rắc rối.</span><br>
<span style="font-weight: 400;">  2.3 Sử dụng 3-layer system:</span><br>
<span style="font-weight: 400;">     + Presentation layer danh cho UI</span><br>
<span style="font-weight: 400;">     + Domain layer cho domain logic</span><br>
<span style="font-weight: 400;">     + Data source</span><br>
<span style="font-weight: 400;">  2.4 Cách này có thể move toàn bộ những phần phức tạp trong domain logic ra ngoài UI và chuyển nó vào một layer nơi xây dụng kiến trúc có đối tượng và các thuộc tính.</span></p>
<p><strong>3. The Three Principal Layers</strong></p>
<p><img src="https://drive.google.com/uc?id=1u01ZzAitnB0Ie7p1wH_iztcnV8_2BeHm&amp;export=download" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"></p>
<ul>
<li>
<p><span style="font-weight: 400;">Presentation logic: Làm thế nào để tương tác giữa người dùng và phần mềm.</span><br>
<span style="font-weight: 400;">    Trách nhiệm chính của presentation layer là:</span><br>
<span style="font-weight: 400;">      + Hiển thị thông tin tới người dùng</span><br>
<span style="font-weight: 400;">      + Thông dịch lệch từ người dùng bên trong actions trên domain và data source </span></p>
</li>
<li>
<p><span style="font-weight: 400;">Domain logic(business logic): Liên quan tới việc tính toán dựa trên những input và stores data, validation những data đên từ presentation, và tìm ra chính xác logic data source nào để dispatch, phụ thuộc vào lệnh nhận được từ presentation.</span></p>
</li>
<li>
<p><span style="font-weight: 400;">Data source logic: Liên kết với hệ thống khác mang các task thay cho application.</span></p>
</li>
</ul>
<p><a href="https://i2.wp.com/vietnamlab.vn/wp-content/uploads/2016/12/layer5.png"><img src="https://i2.wp.com/vietnamlab.vn/wp-content/uploads/2016/12/layer5.png?fit=1035%2C262" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"></a></p>
<ul>
<li><span style="font-weight: 400;">Thỉnh thoảng các layer được sắp xếp vì domain layer hoàn toàn ẩn data source từ presentation.</span></li>
<li><span style="font-weight: 400;">Tuy nhiên, Presentaion truy cập trực tiếp tới data store. Trong khi cái này kém nguyên vẹn, nó có xu hướng làm tốt hơn trong practice</span><br>
<span style="font-weight: 400;">       – Presentation có thể thông dịch một command từ user, dùng data source để kéo dữ liệu thích hợp ra ngoài database</span><br>
<span style="font-weight: 400;">       – Domain logic vận dụng dữ liệu này trước khi biểu diễn nó trên glass(kính)</span></li>
</ul>
<p><a href="https://i2.wp.com/vietnamlab.vn/wp-content/uploads/2016/12/layer6.png"><img src="https://i2.wp.com/vietnamlab.vn/wp-content/uploads/2016/12/layer6.png?fit=981%2C149" alt="Phân lớp (Layering) trong kiến trúc mạng Internet"></a></p>
<p><strong>Separation(sự phân chia):</strong> <span style="font-weight: 400;">Phân chia sự phụ thuộc trên những ứng dụng phức tạp.</span></p>
<ul>
<li><span style="font-weight: 400;">Một script đơn giản pull dữ liệu từ một database và hiển thị nó trong một web page có thể tất cả bằng thủ tục. Nó sẽ tốt hơn nếu tách thành 3 layer. Trong trường hợp đơn giản chúng ta có thể làm nó chỉ bằng việc đặt hành vi vào mỗi layer trong các chương trình con đã được phân chia</span></li>
<li><span style="font-weight: 400;">Hệ thống phức tạp sẽ sẽ chia thành 3 layer bên trong đó sẽ phân chia thành các class.</span></li>
<li><span style="font-weight: 400;">Sự phức tạp đã tăng khi chia các class thành các packages</span></li>
<li><span style="font-weight: 400;">Rule về sự phụ thuộc:</span></li>
<li><span style="font-weight: 400;">Domain và data source có thể chưa bao giờ bị phụ thuộc vào presentation.</span><br>
<span style="font-weight: 400;">      ++ Không thủ tục con nào call từ domain hay data source code bên trong presentation.</span><br>
<span style="font-weight: 400;">      ++  Dễ dàng thay thế các presentaion khác nhau trong tổ chức giống nhau mà không cần phân nhánh xuống sâu hơn. </span></li>
<li><span style="font-weight: 400;">Mối quan hệ giữa domain và data source phức tạp hơn và phụ thuộc vào architectural patterns được dùng cho data source.</span></li>
</ul>
<p><strong>4. Choosing Where to Run Your Layers</strong></p>
<ul>
<li><span style="font-weight: 400;">Data source: Hầu hết luôn luôn chạy trên server</span><br>
<span style="font-weight: 400;">       – Thường xảy ra exception khi bị ngắt kết nối</span><br>
<span style="font-weight: 400;">       – Để thay đổi data source trên client bị ngắt kết nối cần được đồng bộ với server.</span></li>
<li><span style="font-weight: 400;">Domain logic:</span><br>
<span style="font-weight: 400;">       – Có thể chạy business logic toàn bộ trên server hay toàn bộ trên client hay phân tách nó</span><br>
<span style="font-weight: 400;">       – Tất cả trên server là lựa chọn tốt nhất cho việc dễ dàng maintenance.</span><br>
<span style="font-weight: 400;">       – Nhu cầu di chuyển client có thể dùng một trong hai là đáp ứng hay ngắt kết nối</span></li>
<li><span style="font-weight: 400;">Presentaion: Phụ thuộc vào loại UI mình chạy</span></li>
<li><span style="font-weight: 400;">Chạy một rich client có nghĩa là chạy presentation trên client.</span><br>
<span style="font-weight: 400;">       – Chạy Web interface có nghĩa là chạy trên server.</span><br>
<span style="font-weight: 400;">       – Lý do chính để dùng một rich-client presentation là có một vài task phức tap cho user, có thể dùng được application, cần nhiều hơn Web GUI.</span></li>
<li><span style="font-weight: 400;">Nên thử giữ toàn bộ code trên một single process, hoặc là trên một node hay là copy trên một vài node trong một cluster.</span><br>
<span style="font-weight: 400;">       – Đừng thử phân chia layer trong process riêng biệt trừ khi tuyệt đối có. Chú ý tới cả hai việc là performance và thêm những phần phức tạp.</span></li>
</ul>
<p><strong>5. Tổng kết</strong><br>
Cho tới hiện tại hệ thông công nghệ thông tin đã phát triển rất nhanh các hệ thông lớn đã và đang ra đời đỏi hỏi cần phải dùng layer một cách nhuần nhuyễn hơn bao giờ hết. Qua bài viết này này hy vọng mọi người sẽ thiết kế hệ thông của mình tối ưu, dễ quản lý và bảo mật hơn.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[[AWS] Serverless Applications Introduction]]></title><description><![CDATA[<p><strong>Tổng quan bài viết:</strong><br><em><strong>1.</strong> Giới thiệu Serverless Computing và Serverless Architectures<br><strong>2.</strong> Traditional vs Serverless Architecture<br><strong>3.</strong> AWS Lambda<br><strong>4.</strong> Ưu điểm và nhược điểm của Serverless.<br><strong>5.</strong> Tổng kết</em></p><hr><h4 id="i-introdution-serverless-computing-vs-serverless-architectures">I. Introdution Serverless Computing vs Serverless Architectures</h4><ul><li><em><strong><strong>Serverless Computing</strong></strong> </em>là một mô hình thực thi điện toán đám mây</li></ul>]]></description><link>https://blog.vietnamlab.vn/serverless-applications-on-aws/</link><guid isPermaLink="false">5f5f71f2f7370d0001b814ca</guid><dc:creator><![CDATA[Đ.Đ.N]]></dc:creator><pubDate>Sat, 10 Oct 2020 00:00:59 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1V4wOCTkZePcUlyeobiG237YRgT92uxq-&amp;export=download" medium="image"/><content:encoded><![CDATA[<img src="https://drive.google.com/uc?id=1V4wOCTkZePcUlyeobiG237YRgT92uxq-&export=download" alt="[AWS] Serverless Applications Introduction"><p><strong>Tổng quan bài viết:</strong><br><em><strong>1.</strong> Giới thiệu Serverless Computing và Serverless Architectures<br><strong>2.</strong> Traditional vs Serverless Architecture<br><strong>3.</strong> AWS Lambda<br><strong>4.</strong> Ưu điểm và nhược điểm của Serverless.<br><strong>5.</strong> Tổng kết</em></p><hr><h4 id="i-introdution-serverless-computing-vs-serverless-architectures">I. Introdution Serverless Computing vs Serverless Architectures</h4><ul><li><em><strong><strong>Serverless Computing</strong></strong> </em>là một mô hình thực thi điện toán đám mây mà trong đó các nhà cung cấp đám mây sẽ quản lý động việc phân bổ tài nguyên máy, giá cả của mô hình này dựa trên số lượng tài nguyên thực tế mà ứng dụng sử dụng thay vì phải trả trước một khoản nhất định trong một khoảng thời gian. Ngoài ra, một <em><strong>Serverless</strong> <strong>Computing</strong></em> cũng có thể được hiểu là cách mà chúng ta xây dựng lên các ứng dụng khả dụng, sẵn sàng lắng nghe và phản ứng lại với các sự kiện được đưa ra bởi các dịch vụ</li><li><em><strong><strong>Serverless Architectures</strong></strong> </em>là một kiến trúc được xây dựng dựa trên ý tưởng của<em> <strong><strong>Serverless Computing</strong></strong></em></li></ul><hr><h4 id="ii-traditional-vs-serverless-architecture">II. Traditional vs Serverless Architecture</h4><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1RbYMfpn7UOH3yI3mSPrApjJ135eeKkAs&amp;export=download" class="kg-image" alt="[AWS] Serverless Applications Introduction"></figure><p><strong>Price</strong></p><ul><li>Một trong những lợi thế chính của việc sử dụng <strong>Serverless</strong> là giảm thiểu chi phí. </li><li>Mô hình chi phí của <strong>Serverless</strong> tính toán dựa trên những gì thực thi, nghĩa là tính phí cho số lần thực hiện.</li><li>So với mô hình truyền thống thì tiêu chí này chiến thắng thuộc về <strong>Serverless Architecture.</strong></li></ul><p><strong>Network</strong></p><ul><li>Các chức năng <strong>Serverless</strong> chỉ được truy cập dưới dạng API riêng. Để truy cập chúng, bạn phải thiết lập API Gateway. </li><li>Điều này không có tác động đến giá cả hoặc quy trình của bạn, nhưng điều đó có nghĩa là bạn không thể truy cập trực tiếp vào chúng thông qua IP thông thường</li><li>Về tiêu chí này, chiến thắng ở đây thuộc về mô hình kiến trúc truyền thống.</li></ul><p><strong>3rd Party Dependencies</strong></p><ul><li>Hầu hết, nếu không muốn nói là tất cả các dự án của bạn đều có sự phụ thuộc bên ngoài, chúng dựa vào các thư viện không được tích hợp vào ngôn ngữ hoặc khung bạn sử dụng</li><li>Đối với các ứng dụng đơn giản có ít phụ thuộc, <strong>Serverless</strong> là người chiến thắng.</li><li>Đối với bất cứ điều gì phức tạp hơn, mô hình kiến trúc truyền thống là người chiến thắng</li></ul><p><strong>ENV</strong></p><ul><li>Thiết lập các môi trường khác nhau cho <strong>Serverless</strong> cũng dễ như thiết lập một môi trường duy nhất</li><li> Đây là một cải tiến lớn so với các máy chủ truyền thống, bạn không còn cần phải thiết lập các môi trường dev, staging, and production. Cuối cùng, bạn sẽ mất số lượng tất cả các môi trường tại một số điểm.</li><li>Về tiêu chí này chiến thắng ở đây là <strong>Serverless Architecture</strong></li></ul><p><strong>Timeout</strong></p><ul><li>Với tính toán <strong>Serverless</strong>, có giới hạn thời gian chờ 300 giây. Các chức năng quá phức tạp hoặc hoạt động lâu không tốt cho <strong>Serverless</strong>, nhưng thời gian chờ quá khiến bạn không thể thực hiện một số tác vụ nhất định. </li><li>Giới hạn cứng vào thời điểm này làm cho <strong>Serverless</strong> không thể sử dụng được cho các ứng dụng có thời gian thực hiện thay đổi và đối với một số dịch vụ yêu cầu thông tin từ nguồn bên ngoài.</li><li>Dành chiến thắng ở tiêu chí này rõ ràng ở đây là Kiến trúc truyền thống.</li></ul><p><strong>Scale</strong></p><ul><li>Quá trình mở rộng cho Serverless là tự động và không xảy ra downtime, nhưng thiếu kiểm soát hoặc thiếu hoàn toàn kiểm soát. Mặc dù tự động mở rộng rất tuyệt vời, nhưng khó có thể giải quyết và giảm thiểu các lỗi liên quan đến các trường hợp Serverless mới.</li><li>Nó liên kết giữa Serverless và Kiến trúc truyền thống.</li></ul><hr><h4 id="iii-aws-lambda"><strong>III. AWS Lambda</strong></h4><ul><li><strong><strong><a href="https://aws.amazon.com/lambda/" rel="noopener">AWS Lambda:</a></strong></strong> Đây là dịch vụ cloud computing thứ ba của Amazon, nó khác so với 2 dịch vụ còn lại là EC2 (Elastic Compute Cloud) và ECS (Elastic Container Service).</li><li>AWS Lambda là một mô hình <strong><strong>event-driven</strong></strong>, nền tảng <strong><strong>Serverless</strong></strong> trên <strong><strong>AWS</strong></strong> này sẽ thực thi mã của bạn rồi phản hồi lại các sự kiện. Nó sẽ quản lý cơ sở hạ tầng cơ bản và tăng hoặc giảm chúng tùy theo lượng yêu cầu xử lý sự kiện của ứng dụng.</li><li>Hiện tại, <strong><strong>AWS</strong></strong> hỗ trợ các ngôn ngữ là: <strong><strong>Node.js</strong></strong> (JavaScript), <strong><strong>Python</strong></strong>, <strong><strong>Java</strong></strong> (Java 8 compatible), <strong><strong>C#</strong></strong> (.NET Core) và <strong><strong>Go</strong></strong>.</li></ul><hr><h4 id="iv-u-i-m-v-nh-c-i-m-c-a-serverless-">IV. Ưu điểm và nhược điểm của Serverless.</h4><h5 id="1-u-i-m"><strong>1.Ưu điểm</strong></h5><ul><li><strong><strong>Đầu tiên là chi phí:</strong></strong> so với việc thuê server và trả tiền theo tháng hoặc theo năm thì <strong>Serverless</strong> lại tính phí theo thời gian và số lần gọi Function nên chi phí sẽ rẻ hơn, bạn không cần phải trả thêm phí khi mà Server không hoạt động.</li><li><strong><strong>Dễ dàng mở rộng quy mô:</strong></strong> Khi số lượng request tới ứng dụng của bạn tăng cao, nếu thuê hoặc tự xây dựng server thì bạn sẽ phải nâng cấp chúng để đảm bảo tốc độ cho ứng dụng, điều này sẽ tốn nhiều thời gian và nhân lực. Ngược lại, trong mô hình <strong>Serverless</strong>, các nhà cung cấp bên thứ ba sẽ tự lo liệu hết, họ sẽ tự mở rộng thêm các tiến trình và tài nguyên để cân bằng tải khi có nhiều request.</li><li><strong><strong>Deploy code đơn giản hơn:</strong></strong> Bạn sẽ cần có kiến thức xây dựng, triển khai, cấu hình code lên server và bảo trì chúng trong mô hình client-server. Còn với <strong>Serverless</strong>, chỉ cần đẩy code lên, mọi việc còn lại đã có nhà cung cấp dịch vụ xử lý.</li></ul><p><strong>2. Nhược điểm</strong></p><ul><li>Khó khăn cho việc phát triển code ứng dụng ở máy local.</li><li>Khi phát triển ứng dụng, bạn cần để ý tới các dependencies, càng nhiều dependencies thì việc upload ứng dụng của bạn lên càng mất nhiều thời gian.</li><li>Không biết được code của bạn nằm ở đâu cả, tạo cảm giác không an toàn, biết đâu có hacker nào tấn công được vào các máy chủ, thì việc code của bạn bị lấy hoặc sao chép là điều có thể xảy ra.</li><li>Về việc Debug code nữa, những tài nguyên như CPU hay RAM chỉ được quản lý ở bên phía nhà cung cấp dịch vụ cloud nên chúng ta khó tái tạo lại môi trường ở máy local để debug ứng dụng.</li></ul><hr><h4 id="v-t-ng-k-t">V. Tổng kết</h4><p>Trong nội dung bìa viết này, mình đã giới thiệu sơ qua về một thuật ngữ như là <em><strong>Serverless Architecture, Serverless Computing</strong></em> cũng như phân biệt một số điểm khác biệt nổi bật giữa mô hình kiến trúc truyền thống và <em><strong>Serverless</strong></em>. Qua đó, tóm lược được mốt số ưu điểm cũng như nhược nhiểm nhất định. Hi vọng bài viết này sẽ giúp các bạn có một cái nhìn tổng quan nhất về <em><strong>Serverless</strong></em>.</p>]]></content:encoded></item><item><title><![CDATA[Review khóa học Hive to ADVANCE Hive (Real time usage) :Hadoop querying tool]]></title><description><![CDATA[<p>Chào tất cả mọi người, đợt dịch Covid mình có tham gia khóa học về Hive trên Udemy để phục vụ cho dự án. Trong khóa học này, mình sẽ review lại các kiến thức cơ bản và quan trọng khi làm việc với Hive. </p><p>Một số kiến thức cơ</p>]]></description><link>https://blog.vietnamlab.vn/review-khoa-hoc-hive/</link><guid isPermaLink="false">5f71ad782e038c0001cdca64</guid><dc:creator><![CDATA[N.T.A.92]]></dc:creator><pubDate>Sat, 10 Oct 2020 00:00:20 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1dUe-X3WBFXmbSyimYo545uBM8juKppOX&amp;export=download" medium="image"/><content:encoded><![CDATA[<img src="https://drive.google.com/uc?id=1dUe-X3WBFXmbSyimYo545uBM8juKppOX&export=download" alt="Review khóa học Hive to ADVANCE Hive (Real time usage) :Hadoop querying tool"><p>Chào tất cả mọi người, đợt dịch Covid mình có tham gia khóa học về Hive trên Udemy để phục vụ cho dự án. Trong khóa học này, mình sẽ review lại các kiến thức cơ bản và quan trọng khi làm việc với Hive. </p><p>Một số kiến thức cơ bản mình sẽ chia sẻ với mọi người trong slide là </p><ol><li>Hive là gì ?</li><li>Partition và Bucketing trong Hive</li><li>Join optimize performace trong Hive</li><li>UDF's (User defined function in Hive)</li><li>Variables trong Hive </li></ol><p>Ngoài ra còn một vài kiến thức cơ bản khác như : Các hàm hay sử dụng, sorting, load XML data vào Hive...Mình sẽ cố gắng tạo các ví dụ demo của khóa học này để mọi người cùng theo dõi.</p><p>Dưới đây là slide mình review lại, nếu bạn nào có comment câu hỏi vui lòng comment trong blog này nhé. Mình sẽ trả lời trong sự hiểu biết của mình.</p><p>Slide sẽ upload sau khi trình bày kết quả với công ty.</p>]]></content:encoded></item><item><title><![CDATA[MariaDB-Mysql Store Engine]]></title><description><![CDATA[<p>Ngày nay ứng dụng web có rất nhiều lựa chọn cơ sở dữ liệu (database), đối với các nên tảng mã nguồn mở nhất là PHP, MySQL là sự lựa chọn vô cùng phổ biến trong một thời gian dài. Tuy nhiên công nghệ ngày càng phát triển, với sự</p>]]></description><link>https://blog.vietnamlab.vn/mariadb-mysql-store-engine/</link><guid isPermaLink="false">5f71abaf2e038c0001cdca61</guid><category><![CDATA[MySQL]]></category><category><![CDATA[MariaDB]]></category><category><![CDATA[Spider engine]]></category><dc:creator><![CDATA[P.V.Đ]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:59:53 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1vokG3s6uGMMQFlrSfQJQhTAoAju9gX3C&amp;export=download" medium="image"/><content:encoded><![CDATA[<img src="https://drive.google.com/uc?id=1vokG3s6uGMMQFlrSfQJQhTAoAju9gX3C&export=download" alt="MariaDB-Mysql Store Engine"><p>Ngày nay ứng dụng web có rất nhiều lựa chọn cơ sở dữ liệu (database), đối với các nên tảng mã nguồn mở nhất là PHP, MySQL là sự lựa chọn vô cùng phổ biến trong một thời gian dài. Tuy nhiên công nghệ ngày càng phát triển, với sự xuất hiện của MariaDB và Percona, là 2 nhánh biến thể của MySQL với nhiều tính năng vượt trội. Bài viết này sẽ giới thiệu và MariaDB Spider Engine dành cho nhưng ứng dụng có lượng dự liệu lớn hoặc muốn mở rộng hơn nữa.</p><!--kg-card-begin: html--><iframe src="//www.slideshare.net/slideshow/embed_code/key/F05T8PZd3EuWsO" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/dongpvhy/maria-db-spider-engine" title="Maria db spider engine" target="_blank">Maria db spider engine</a> </strong> from <strong><a href="https://www.slideshare.net/dongpvhy" target="_blank">Đông Đô</a></strong> </div><!--kg-card-end: html--><p><a href="https://github.com/dongpv91/mariadb-spider-engine">https://github.com/dongpv91/mariadb-spider-engine</a></p>]]></content:encoded></item><item><title><![CDATA[Hướng dẫn cách tạo slide show ẩn hiện bằng jquery]]></title><description><![CDATA[<!--kg-card-begin: markdown--><h3 id="igiithiu">I.Giới thiệu:</h3>
<ul>
<li>Slideshow là 1 ứng dụng rất phổ biến trong UI web.</li>
<li>Hiện có rất nhiều plugin hỗ trợ slideshow.</li>
<li>Tuy nhiên trường hợp nếu plugin không hỗ trợ hoặc không phù hợp với css, layout trang web của bạn thì việc biết cách code 1 slide hoặc</li></ul>]]></description><link>https://blog.vietnamlab.vn/huong-dan-cach-tao-slide-show-an-hien-bang-jquery/</link><guid isPermaLink="false">5f6d67ba2e038c0001cdca57</guid><dc:creator><![CDATA[H.H.T]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:59:23 GMT</pubDate><media:content url="https://drive.google.com/uc?id=19I_XA4EFprlSXSBPc2vZbiKjWlNiiWDY&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h3 id="igiithiu">I.Giới thiệu:</h3>
<ul>
<li>Slideshow là 1 ứng dụng rất phổ biến trong UI web.</li>
<li>Hiện có rất nhiều plugin hỗ trợ slideshow.</li>
<li>Tuy nhiên trường hợp nếu plugin không hỗ trợ hoặc không phù hợp với css, layout trang web của bạn thì việc biết cách code 1 slide hoặc hiểu rõ slide có thể giúp bạn tự tạo 1 slideshow khác phù hợp hoặc có thể tùy biến plugin 1 cách hiệu quả.</li>
</ul>
<h3 id="iidemoslideshow">II.Demo slideshow:</h3>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><!DOCTYPE html>
<html>
<body>
  <div class="container_slide_show">
    <ul id="slide_show">
      <li><img src="https://drive.google.com/uc?id=1v7aWBprVbiMpWfSH-uO2TEImFQtGLD-q&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></li>
      <li><img src="https://drive.google.com/uc?id=1klZhGCLEJ7R1unWXsIQxEygN-A8rsGVP&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></li>
      <li><img src="https://drive.google.com/uc?id=1t9z1ArmIMmaCMpSYMEw2ICbXchHrfDND&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></li>
      <li><img src="https://drive.google.com/uc?id=1aTQBUVnrFfR00wbVAzNezipxeFk9HGo3&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></li>
      <li><img src="https://drive.google.com/uc?id=1IWrzv-kiTnyYt1bxgKGPN_6v1TE5T3_r&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></li>
    </ul>
    <div class="container_button clearfix">
      <button id="prev_slide" class="slide_btn">Prev</button>
      <button id="next_slide" class="slide_btn">Next</button>
    </div>
  </div>
</body>
</html>
<script src="https://code.jquery.com/jquery-1.7.0.min.js"></script>
<script>
  $('#slide_show > li:first').css('display', 'block').addClass('active');
  var isHoverBtn = false;

  $('#next_slide').bind('click', function() {
    runSlide(true);
  });

  $('#prev_slide').bind('click', function() {
    runSlide(false);
  });

  $('.slide_btn').hover(function() {
    isHoverBtn = true;
  }, function() {
    isHoverBtn = false;
  });

  setInterval(function(){
    if (!isHoverBtn) {
      runSlide(true);
    }
  }, 3000);


  function runSlide(isNext) {
    var oldItem = $('#slide_show > li.active');
    var newItem;
  
    if (isNext) {
      newItem = oldItem.next();

      if (newItem.length === 0) {
        newItem = $('#slide_show > li:first');
      }
    } else {
      newItem = oldItem.prev();

      if (newItem.length === 0) {
        newItem = $('#slide_show > li:last');
      }
    }

    if (newItem.length === 0) {
      newItem = $('#slide_show > li:eq(0)');
    }

    oldItem.fadeOut(function() {
      $(this).removeClass('active');
    });

    newItem.fadeIn(function() {
        $(this).addClass('active');
      });
  }
</script>
<style>
#slide_show {
  width: 400px;
  height: 200px;
  overflow: hidden;
  position: relative;
}
#slide_show > li {
  position: absolute;
  top: 0;
  left: 0;
  display: none;
}
#slide_show > li > img {
  list-style: none;
  width: 400px;
}
.container_slide_show {
  display:block;
  width: 400px;
  margin: 0 auto;
}
.container_button {
  margin-top: 5px;
}
.slide_btn {
  width: 50px;
  height: 30px;
  border: none;
  color: #ffffff;
  cursor: pointer;
}
#prev_slide {
  float: left;
  background-color: #008CBA;
}
#next_slide {
  float: right;
  background-color: #4CAF50;
}
.clearfix:after{
    clear: both;
    content: ".";
    display: block;
    width: 0px;
    height: 0px;
}
</style><!--kg-card-end: html--><!--kg-card-begin: markdown--><h3 id="iiitngcode">III. Ý tưởng code:</h3>
<ul>
<li>
<img src="https://drive.google.com/uc?id=19I_XA4EFprlSXSBPc2vZbiKjWlNiiWDY&export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"><p>Đầu tiên chúng ta sẽ có 1 danh sách hình ảnh. Sau đó xếp chồng chúng lên nhau như hình dưới đây.<br>
<img src="https://drive.google.com/uc?id=1lGkbKxNIafJPDlRXPnIMYZ7er_pCnqY8&amp;export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></p>
</li>
<li>
<p>Việc xếp chồng sẽ được thực hiện bởi css. Cụ thể là container bao bên ngoài danh sách ảnh sẽ có thuộc tính <em>position: relative</em> trong khi đó từng item hình ảnh sẽ có thuộc tính <em>position: absolute; top:0; left:0</em> đây là các css giúp các item hình ảnh xếp thành 1 chồng.</p>
</li>
<li>
<p>Tiếp theo ẩn tất các các hình ảnh bằng thuộc tính <em>display: none</em>, tuy nhiên ngoại lệ hình đầu tiền sẽ được hiện bằng thuộc tính <em>display: block</em>, và hình ảnh đầu tiên sẽ được thêm 1 class active để đánh dấu là item hình ảnh được hiện.</p>
</li>
</ul>
<p><img src="https://drive.google.com/uc?id=1Wbb5YWWBGiGn-CRI8ctgTKuQsEXeK7QU&amp;export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></p>
<ul>
<li>
<p>Khi slide chạy, đầu tiên cần xác định item ảnh nào đang có class active thì ẩn item đó đi remove class active sau đó chọn phần tử next tiếp theo hiện nó lên và thêm vào class active<br>
<img src="https://drive.google.com/uc?id=1j8ZxL38nk1f3FSjydHmveLjBjD2zsf_B&amp;export=download" alt="Hướng dẫn cách tạo slide show ẩn hiện bằng jquery"></p>
</li>
<li>
<p>Trường hợp chạy đến cuối slide nếu muốn slide chạy vô cực thì hay chuyển active về phần tử đâu tiên.</p>
</li>
</ul>
<h3 id="ivsourcecode">IV. Source code:</h3>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;div class=&quot;container_slide_show&quot;&gt;
    &lt;ul id=&quot;slide_show&quot;&gt;
      &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot; &gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot; &gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot; &gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot; &gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot; &gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div class=&quot;container_button&quot;&gt;
      &lt;button id=&quot;prev_slide&quot; class=&quot;slide_btn&quot;&gt;Prev&lt;/button&gt;
      &lt;button id=&quot;next_slide&quot; class=&quot;slide_btn&quot;&gt;Next&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-1.7.0.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $('#slide_show &gt; li:first').css('display', 'block').addClass('active');
  var isHoverBtn = false;

  $('#next_slide').bind('click', function() {
    runSlide(true);
  });

  $('#prev_slide').bind('click', function() {
    runSlide(false);
  });

  $('.slide_btn').hover(function() {
    isHoverBtn = true;
  }, function() {
    isHoverBtn = false;
  });

  setInterval(function(){
    if (!isHoverBtn) {
      runSlide(true);
    }
  }, 3000);


  function runSlide(isNext) {
    var oldItem = $('#slide_show &gt; li.active');
    var newItem;
  
    if (isNext) {
      newItem = oldItem.next();

      if (newItem.length === 0) {
        newItem = $('#slide_show &gt; li:first');
      }
    } else {
      newItem = oldItem.prev();

      if (newItem.length === 0) {
        newItem = $('#slide_show &gt; li:last');
      }
    }

    if (newItem.length === 0) {
      newItem = $('#slide_show &gt; li:eq(0)');
    }

    oldItem.fadeOut(function() {
      $(this).removeClass('active');
    });

    newItem.fadeIn(function() {
        $(this).addClass('active');
      });
  }
&lt;/script&gt;
&lt;style&gt;
*{
  padding:0px;
  margin:0px;
}
html{
  width:100%;
  height:100%;
}
body{
  height:100%;
  width:100%;
}
html &gt; body {
     height: 100%;
}
#slide_show {
  width: 400px;
  height: 200px;
  overflow: hidden;
  position: relative;
}
#slide_show &gt; li {
  position: absolute;
  top: 0;
  left: 0;
  display: none;
}
#slide_show &gt; li &gt; img {
  list-style: none;
  width: 400px;
}
.container_slide_show {
  width: 400px;
  margin: 0 auto;
}
.container_button {
  margin-top: 5px;
}
.slide_btn {
  width: 50px;
  height: 30px;
  border: none;
  color: #ffffff;
  cursor: pointer;
}
#prev_slide {
  float: left;
  background-color: #008CBA;
}
#next_slide {
  float: right;
  background-color: #4CAF50;
}
&lt;/style&gt;
</code></pre>
<h3 id="vktlun">V. Kết luận:</h3>
<ul>
<li>Hiện tại các plugin về slideshow khá tốt nên mình vẫn khuyến khích dùng plugin.</li>
<li>Tuy nhiên công việc trong ngành IT không phải ngày nào cũng giống nhau, không phải lúc nào khách hàng cũng yêu cầu 1 cái slideshow bình thường.</li>
<li>Sẽ có lúc khách hàng đưa ra những yêu cầu đặc biệt ví dụ như slideshow đôi, hoặc 1 slideshow có vài trăm ảnh yêu cầu dùng ajax, lazy loading để chạy tới đâu load tới đó, trong trường hợp đó thì việc có những kiến thức cơ bản sẽ giúp chúng ta xoay sở tốt hơn.</li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[CI, CD với TravisCI và AWS Elastic Beanstalk]]></title><description><![CDATA[<p>Có rất nhiều công cụ để sử dụng cho việc CI, CD một dự án, ở bài viết này chúng ta sẽ cùng tìm hiểu về cách để làm việc với TravisCI.</p><h2 id="1-t-m-hi-u-v-travisci">1. Tìm hiểu về TravisCI</h2><blockquote><strong><strong>Travis</strong></strong> là một dịch vụ (service) CI, miễn phí và là open source.</blockquote>]]></description><link>https://blog.vietnamlab.vn/ci-cd-voi-travisci-va-aws-elastic-beanstalk/</link><guid isPermaLink="false">5f71add52e038c0001cdca68</guid><category><![CDATA[dockerfile]]></category><category><![CDATA[AWS]]></category><category><![CDATA[CI]]></category><category><![CDATA[CD]]></category><category><![CDATA[CI/CD]]></category><dc:creator><![CDATA[L.T.Đ]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:58:48 GMT</pubDate><media:content url="https://drive.google.com/uc?id=15MXbMmYLjFUjvHLzRhsAZNHj2kc9Ore3&amp;export=download" medium="image"/><content:encoded><![CDATA[<img src="https://drive.google.com/uc?id=15MXbMmYLjFUjvHLzRhsAZNHj2kc9Ore3&export=download" alt="CI, CD với TravisCI và AWS Elastic Beanstalk"><p>Có rất nhiều công cụ để sử dụng cho việc CI, CD một dự án, ở bài viết này chúng ta sẽ cùng tìm hiểu về cách để làm việc với TravisCI.</p><h2 id="1-t-m-hi-u-v-travisci">1. Tìm hiểu về TravisCI</h2><blockquote><strong><strong>Travis</strong></strong> là một dịch vụ (service) CI, miễn phí và là open source. Trong đó CI là viết tắt của từ Continuous Integrantion, nghĩa là tích hợp liên tục. </blockquote><p> Travis CI cùng đã từng được giới thiệu ở blog vietnamlab. Các bạn có thể tham khảo thêm ở <a href="https://blog.vietnamlab.vn/2017/03/17/tim-hieu-travis-ci-github-voi-project-php/">đây</a>.</p><h2 id="2-t-m-hi-u-v-aws-elastic-beanstalk">2. Tìm hiểu về AWS Elastic Beanstalk</h2><blockquote>AWS Elastic Beanstalk là một dịch vụ dễ sử dụng để triển khai và mở rộng các ứng dụng web và dịch vụ . Bạn có thể dễ dàng tải mã của bạn lên và Elastic Beanstalk sẽ tự động xử lý việc triển khai, từ cung cấp công suất, cân bằng tải, tự động điều chỉnh quy mô đến giám sát trạng thái ứng dụng. Đồng thời, bạn vẫn có toàn quyền kiểm những tài nguyên AWS vận hành ứng dụng của bạn và có thể truy cập các tài nguyên quan trọng vào bất kỳ lúc nào.</blockquote><p>Nói một cách đơn giản thì EB giống như một dịch vụ giúp bạn tự động sử dụng các dịch vụ khác của AWS như EC2, VPC, S3 v.v... </p><h2 id="3-thi-t-l-p-elastic-beanstalk">3. Thiết lập Elastic Beanstalk</h2><h3 id="3-1-thi-t-l-p-permission-cho-user-">3.1 Thiết lập permission cho user.</h3><p>Ở service IAM, chúng ta thêm permission AWSElasticBeanStalkFullAccess.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1FygYkJJgu5k7jIxcQv2p3RSF1yB6Or6U&amp;export=download" class="kg-image" alt="CI, CD với TravisCI và AWS Elastic Beanstalk"></figure><h3 id="3-2-t-o-application-v-enviroment">3.2 Tạo application và enviroment</h3><p>Truy cập vào link <a href="https://console.aws.amazon.com/elasticbeanstalk/home#/gettingStarted?applicationName=getting-started-app">này</a>. Chọn platform và chọn <strong>Create enviroment</strong>. Ở đây chúng ta sẽ chọn docker. Ở mục <strong>Application code</strong> tạm thời chọn <strong>Sample application</strong>. Chúng ta sẽ dùng TravisCI để update version lại sau. Ở bước này chúng ta sẽ phải memo lại một số thông tin như application name, và enviroment name để cung cấp cho quá trình deploy ở Travis.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1Q4enKHaanYpDPrOKdneFWWHTcjyyg4ky&amp;export=download" class="kg-image" alt="CI, CD với TravisCI và AWS Elastic Beanstalk"></figure><h3 id="3-3-memo-l-i-bucket-name">3.3 Memo lại bucket name</h3><p>Truy cập dịch vụ S3. Lưu lại bucket name của bucket vừa được tạo ra bởi EB.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1sym9RlptkOT0tv451moSx5Q3Txn6lUMt&amp;export=download" class="kg-image" alt="CI, CD với TravisCI và AWS Elastic Beanstalk"></figure><h3 id="3-4-thi-t-l-p-file-dockerrun-aws-json">3.4 Thiết lập file Dockerrun.aws.json</h3><p>Ở thư mực gốc của dự án. Chúng ta sẽ tạo một file Dockerrun.aws.json. Có nội dung như sau:</p><!--kg-card-begin: markdown--><pre><code>{
    &quot;AWSEBDockerrunVersion&quot;: &quot;1&quot;,
    &quot;Image&quot;: {
        &quot;Name&quot;: &quot;ltdat1095/backend:latest&quot;,
        &quot;Update&quot;: &quot;true&quot;
    },
    &quot;Ports&quot;: [
        {
            &quot;ContainerPort&quot;: 8080,
            &quot;HostPort&quot;: 8080
        }
    ]
}
</code></pre>
<!--kg-card-end: markdown--><p>Với name sẽ là tên của image đã được build và push lên dockerhub.</p><h3 id="3-5-thi-t-l-p-file-travis">3.5 Thiết lập file travis</h3><p>Ở thư mục gốc của dự án. Chúng ta tạo file .travis.yml với nội dung như sau</p><!--kg-card-begin: markdown--><pre><code>dist: bionic
sudo: required
services:
  - docker

notifications:
  email: false

script:
  - docker build -t $DOCKER_ID/backend:latest -f ./ops/production/Dockerfile .

after_success:
  - echo &quot;$DOCKER_PASS&quot; | docker login -u $DOCKER_ID --password-stdin
  - docker push $DOCKER_ID/backend:latest 

deploy:
  edge: true
  provider: elasticbeanstalk
  region: ap-southeast-1
  app: $AWS_EB_APP
  env: $AWS_EB_ENV
  bucker_name: $AWS_BUCKER_NAME
  bucker_path: backend
  on:
    branch : master
  access_key_id: $AWS_ACCESS_ID
  secret_access_key: $AWS_ACCESS_SECRET
</code></pre>
<!--kg-card-end: markdown--><p>Với đoạn code trên kịch bản deploy của chúng ta sẽ là:</p><ol><li>Build docker image với</li><li>Push docker image đó lên docker hub</li><li>Deploy lên EB với các thông số đã thu được ở các bước trước đó.</li></ol><h3 id="3-6-thi-t-l-p-c-c-bi-n-m-i-tr-ng-cho-travis">3.6 Thiết lập các biến môi trường cho Travis</h3><p>Ở Dashboard của Travis, click chọn <strong>More Options</strong> -&gt; <strong>Settings </strong>và thêm các biến môi trường đã thu được vào Travis.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1bjQIxdZrVDFYwrEvGSQWPMY3ebLfF5f6&amp;export=download" class="kg-image" alt="CI, CD với TravisCI và AWS Elastic Beanstalk"></figure><p>Đến đây thì mọi thứ đã xong chúng ta chỉ cần push code lên nhánh master và chờ Travis, EB làm hết phần việc còn lại nữa thôi</p><h2 id="4-tham-kh-o-">4. Tham khảo:</h2><p><a href="https://blog.vietnamlab.vn/2017/03/17/tim-hieu-travis-ci-github-voi-project-php/">https://blog.vietnamlab.vn/2017/03/17/tim-hieu-travis-ci-github-voi-project-php/</a></p><p><a href="https://aws.amazon.com/vi/elasticbeanstalk/#:~:text=AWS%20Elastic%20Beanstalk%20l%C3%A0%20m%E1%BB%99t,%C4%91%C6%B0%E1%BB%A3c%20ph%C3%A1t%20tri%E1%BB%83n%20b%E1%BA%B1ng%20Java%2C%20.&amp;text=B%E1%BA%A1n%20c%C3%B3%20th%E1%BB%83%20d%E1%BB%85%20d%C3%A0ng,s%C3%A1t%20tr%E1%BA%A1ng%20th%C3%A1i%20%E1%BB%A9ng%20d%E1%BB%A5ng.">https://aws.amazon.com/vi/elasticbeanstalk/</a></p>]]></content:encoded></item><item><title><![CDATA[Khoảng tin cậy cho trung bình (Toán thống kê phần 4)]]></title><description><![CDATA[<!--kg-card-begin: markdown--><h3 id="mu">Mở đầu</h3>
<p>Bài blog này sẽ giải thích cách tính khoảng tin cậy (confidence interval) cho trung bình. Bài đề cập đến các khái niệm phân phối chuẩn và khoảng tin cậy cho tỷ lệ trong hai bài blog trước. Các bạn có thể đọc ở đây:</p>
<ol>
<li>Phân phối chuẩn</li></ol>]]></description><link>https://blog.vietnamlab.vn/confidence-interval-cho/</link><guid isPermaLink="false">5effec64f7370d0001b8142c</guid><dc:creator><![CDATA[L.M.L]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:58:22 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h3 id="mu">Mở đầu</h3>
<p>Bài blog này sẽ giải thích cách tính khoảng tin cậy (confidence interval) cho trung bình. Bài đề cập đến các khái niệm phân phối chuẩn và khoảng tin cậy cho tỷ lệ trong hai bài blog trước. Các bạn có thể đọc ở đây:</p>
<ol>
<li>Phân phối chuẩn và các giá trị thống kê<br>
<a href="https://blog.vietnamlab.vn/2019/12/20/cac-loai-phan-phoi-va-tinh-chat/">https://blog.vietnamlab.vn/2019/12/20/cac-loai-phan-phoi-va-tinh-chat/</a></li>
<li>Khoảng tin cậy cho tỉ lệ<br>
<a href="https://blog.vietnamlab.vn/2020/06/23/toan-thong-ke-2/">https://blog.vietnamlab.vn/2020/06/23/toan-thong-ke-2/</a></li>
</ol>
<h3 id="cngthc">Công thức</h3>
<h4 id="cngthctnhkhongtincychotrungbnhsdnglchchuncathp">Công thức tính khoảng tin cậy cho trung bình sử dụng độ lệch chuẩn của tổ hợp</h4>
<p>Công thức tính khoảng tin cậy cho trung bình là như sau:<br>
<img src="https://drive.google.com/uc?id=1YW_KgCnNogdNZ5v3TbbcfWmGaiI7Qv__&amp;export=download" alt="uc?id=1YW_KgCnNogdNZ5v3TbbcfWmGaiI7Qv__&amp;export=download"><br>
Để tính khoảng tin cậy của trung bình cho một tập dữ liệu đầu tiên ta sẽ lấy một mẫu dữ liệu trước. Từ mẫu dữ liệu đó ta sẽ lấy trung bình cộng của mẫu dữ liệu.<br>
Sau đó ta sẽ tính z-score dựa vào mức tin cậy. Ví dụ như hình dưới đây với mức tin cậy là 95% trong phân phối mẫu của trung bình mẫu, sẽ được thể hiện bằng diện tích màu đỏ giữa hai gạch đỏ.<br>
<img src="https://drive.google.com/uc?id=1V9cNLU64qxfcSCxXS6x-VEUpgcNVnD7g&amp;export=download" alt="uc?id=1V9cNLU64qxfcSCxXS6x-VEUpgcNVnD7g&amp;export=download"><br>
Với phần lớn dữ liệu, nếu ta tập hợp thật nhiều mẫu, tính trung bình của các mẫu rồi vẽ phân phối của trung bình, ta sẽ vẽ được một phân phối như trong hình. Về lý thuyết, trung bình của phân phối mẫu sẽ bằng trung bình của tổ hợp. Mức tin cậy là khả năng trung bình của tập hợp nằm giữa hai giá trị trong phân phối của trung bình mẫu. Hai giá trị này, được thể hiện bằng hai đường gạch màu đỏ cắt với trục X, có cùng khoảng cách với trung bình. Mức tin cậy bằng 95% có nghĩa là ta phải tìm hai đường gạch đỏ (đối xứng tại trung bình) như thế nào để khả năng trung bình của tập hợp nằm giữa hai giá trị là 95% (diện tích dưới đường cong).<br>
Ví dụ tìm z-score với mức tin cậy là 95%. Cách thứ nhất ta có thể dùng luật 68, 95, và 99.7 (có thể xem trên wiki). Vì diện tích dưới đường cong ở giữa là 95%, z-score là gần bằng -2 bên trái và 2 bên phải.<br>
Một cách khác, ta có thể tìm diện tích dưới đường cong bên tay trái phân phối (diện tích màu xanh bên trái hình). Diện tích đó sẽ là: (100% - 95%)/2 = 2.5% = 0.025. Sử dụng z-table và z-score của diện tích bên trái sẽ cho kết quả -1.96, làm tròn thành -2. Z-score bên phải sẽ là giá trị tuyệt đối của -2 bằng 2. Cách sử dụng z-table có thể thấy như hình bên dưới.<br>
<img src="https://drive.google.com/uc?id=1m-e1kGMJxXw0L3VCyroCUmYw2F_-fHjf&amp;export=download" alt="uc?id=1m-e1kGMJxXw0L3VCyroCUmYw2F_-fHjf&amp;export=download"><br>
<img src="https://drive.google.com/uc?id=1R7zuMnornQIbBHrSVGURjmCXhA_48nTL&amp;export=download" alt="uc?id=1R7zuMnornQIbBHrSVGURjmCXhA_48nTL&amp;export=download"><br>
Cuối cùng ta sẽ tính độ lệch chuẩn của trung bình trong phân phối mẫu bằng độ lệch của tổ hợp dữ liệu chia cho căn bậc hai của số dữ liệu trong mẫu dữ liệu. Sau khi tính được các giá trị trên các bạn có thể cộng trừ nhân chia như công thức trên để tính khoảng tin cậy trong trường hợp ta biết độ lệch chuẩn của tổ hợp dữ liệu.</p>
<h4 id="cngthctnhkhongtincychotrungbnhsdnglchchuncamu">Công thức tính khoảng tin cậy cho trung bình sử dụng độ lệch chuẩn của mẫu</h4>
<p>Điểm cần lưu ý là rất ít trường hợp chúng ta biết được độ lệch chuẩn của tổ hợp dữ liệu. Nên bình thường ta sẽ sử dụng độ lệch chuẩn của mẫu thay bằng độ lệch chuẩn của tổ hợp để đưa ra kết quả tương tự.<br>
Công thức tính độ lệch chuẩn cho phân phối của trung bình mẫu sử dụng độ lệch chuẩn của mẫu:<br>
<img src="https://drive.google.com/uc?id=1pwPRGtNyqswJ7FASZ038EIzWlIowVko8&amp;export=download" alt="uc?id=1pwPRGtNyqswJ7FASZ038EIzWlIowVko8&amp;export=download"><br>
Tuy nhiên các nhà toán học qua thí nghiệm thống kê thấy, nếu sử dụng độ lệch chuẩn của mẫu để tính độ lệch chuẩn cho trung bình như ở trên, sẽ đưa ra khoảng tin cậy không chính xác. Họ thấy nếu sử dụng độ lệch chuẩn của mẫu thay bằng độ lệch chuẩn của tổ hợp, thì sử dụng t-score sẽ chính xác hơn so với z-score.<br>
Ta sẽ có công thức ước lượng khoảng tin cậy sử dụng độ lệch chuẩn của dữ liệu mẫu:<br>
<img src="https://drive.google.com/uc?id=1zodaL6yhs_fflv0v7ed8pL0WQ7qwZmfz&amp;export=download" alt="uc?id=1zodaL6yhs_fflv0v7ed8pL0WQ7qwZmfz&amp;export=download"><br>
Để nhớ lại. Z-score và T-score làm cùng nhiệm vụ: tìm khoảng cách từ một giá trị bất kỳ đến trung bình trong một phân phối. Điểm khác nhau là z-score sử dụng cho phân phối Z. T-score sử dụng cho phân phối T, là phân phối có đuôi phình hơn phân phối Z.<br>
<img src="https://drive.google.com/uc?id=1KkVUdnBZt2PbFB5diOjSN0bcW2fn5Adg&amp;export=download" alt="uc?id=1KkVUdnBZt2PbFB5diOjSN0bcW2fn5Adg&amp;export=download"><br>
Một điểm cần lưu ý nữa. Để sử dụng t-score ta phải biết bậc tự do (degrees of freedom). Bậc tự do = số dữ liệu mẫu - 1. Ví dụ trong mẫu của chúng ta có 10 dữ liệu và ta muốn tìm t-score với mức tin cậy là 95%. Bậc tự do sẽ là 10 -1 = 9, diện tích dưới đường cong ở bên trái sẽ là (100% - 95%)/2 = 2.5% = 0.025. Bạn cũng có thể sử dụng trức tiếp mức tin cậy là 95% thay bằng diện tích dưới đường cong bên trái (0.025). Sử dụng t-table như bên dưới ta sẽ tìm được t-score là 2.262.<br>
<img src="https://drive.google.com/uc?id=11QDOQ62ZT5-TcFZvdyS-gB8d3G_nrC9A&amp;export=download" alt="uc?id=11QDOQ62ZT5-TcFZvdyS-gB8d3G_nrC9A&amp;export=download"></p>
<p>Vậy khi tính giới hạn lỗi cho trung bình, ta có thể sử dụng z-score với dộ lệch chuẩn của tổ hợp, và t-score với độ lệch chuẩn của mẫu.</p>
<h3 id="biton">Bài toán</h3>
<p>Sử dụng công thức ở trên, ta sẽ giải một bài toán về khoảng tin cậy sử dụng python.</p>
<p>Một nhà chuyên gia dinh dưỡng nghiên cứu về số ca-lo trong bánh mì kẹp thịt của chuỗi nhà hàng nổi tiếng. Nhà chuyên gia lấy một mẫu ngẫu nhiên gồm 14 bánh mì kẹp thịt và đo số ca-lo. Mẫu dữ liệu có phân bố gần đối xứng, giá trị trung bình là 700 ca-lo và độ lệch chuẩn là 50 ca-lo. Hỏi với mẫu dữ liệu này, với  mức độ tin cậy là 95%, khoảng cách tin cậy cho trung bình số ca-lo của bánh mì kẹp thịt này là bao nhiêu?</p>
<p>Tập hợp lại các thông tin từ bài toán</p>
<pre><code class="language-python">    sample_mean = 700
    sample_stddev = 50
    n_size = 14
    confidence_level = 0.95
</code></pre>
<p>Tính các giá trị để tính t-value: bậc giá trị và diện tích đường cong bên tay trái</p>
<pre><code class="language-python">    # Tính bậc tự do
    degrees_of_freedom = n_size - 1
    # Tính xác xuất giá trị nằm bền trái t-value trong phân phối t (t-distribution)
    one_tailed_prob = (1 - 0.95)/2
    one_tailed_prob # 0.025
</code></pre>
<p>Sau đó chúng ta tính t-value.</p>
<pre><code class="language-python">    # Tính t-value 
    t_value = stats.t.ppf(1 - one_tailed_prob, degrees_of_freedom)
    t_value # 2.1603686564610127
</code></pre>
<p>Tính độ lệch chuẩn cho phân phối mẫu của trung bình mẫu</p>
<pre><code class="language-python">    from math import sqrt
    sampling_dist_mean_stddev = sample_stddev/sqrt(n_size)
    sampling_dist_mean_stddev # 13.363062095621219
</code></pre>
<p>Tính khoảng tin cậy</p>
<pre><code class="language-python">    confidence_interval_1 =  sample_mean - (t_value*sampling_dist_mean_stddev)
    confidence_interval_2 =  sample_mean + (t_value*sampling_dist_mean_stddev)
    confidence_intervals = (confidence_interval_1, confidence_interval_2)
    confidence_intervals # (671.1308594942777, 728.8691405057223)
</code></pre>
<p>Tính khoảng tin cậy bằng function có sẵn trong scipy. Lưu ý là chúng ta sử dụng độ lệch chuẩn của phân phối mẫu trong trung bình mẫu (sampling_dist_mean_stddev), không phải độ lệch chuẩn của mẫu (sample_stddev).</p>
<pre><code class="language-python">    from scipy.stats import t
    check_confidence_intervals = t.interval(alpha=confidence_level, df=degrees_of_freedom, loc=sample_mean, scale=sampling_dist_mean_stddev)
    check_confidence_intervals # (671.1308594942777, 728.8691405057223)
</code></pre>
<p>Có thể thấy là chúng ta tính đúng vì kết quả ở trên giống với kết quả này. Vậy khoảng tin cậy trung bình sẽ gần bằng (671, 729)</p>
<p>Phân tích kết quả<br>
Với mức tin cậy là 95%, khoảng tin cậy cho trung bình chúng ta tìm được là  (671, 729). Điều này có nghĩa là ta có thể tự tin 95% là trung bình calo trong toàn bộ bánh mì kẹp thịt của cửa hàng này sẽ nằm trong khoảng từ 671 và 729 calo</p>
<h3 id="ktlun">Kết luận</h3>
<p>Hi vọng với bài blog này các bạn hiểu được cách tính và phân tích khoảng tin cậy cho trung bình. Chúc các bạn may mắn trong việc áp dụng vào dự án.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Giới thiệu về package net/http của ngôn ngữ Go (Phần 1)]]></title><description><![CDATA[Cùng tìm hiểu về package net/http của ngôn ngữ Go, công cụ để phát triển web application mà bất kì Go developer nào cũng cần phải tìm hiểu qua]]></description><link>https://blog.vietnamlab.vn/gioi-thieu-ve-package-net-http-cua-ngon-ngu-go/</link><guid isPermaLink="false">5f6b00f72e038c0001cdca51</guid><category><![CDATA[golang]]></category><category><![CDATA[net/http]]></category><dc:creator><![CDATA[T.M.L]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:57:40 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1ecIfCDMD-IQmFY6yckXT9zC-H51mW9DN&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://drive.google.com/uc?id=1ecIfCDMD-IQmFY6yckXT9zC-H51mW9DN&export=download" alt="Giới thiệu về package net/http của ngôn ngữ Go (Phần 1)"><p>hi tìm hiểu về ngôn ngữ lập trình Go, lời khuyên mà người mới học thường gặp nhất là thay vì tìm một web framework có sẵn thì hãy tìm hiểu và sử dụng package <code>net/http</code> đi kèm sẵn của Go. Có thể thấy, <code>net/http</code> thật sự rất mạnh, đủ dùng cho phần lớn các trường hợp phát triển web thông thường. Ở bài viết này, chúng ta cũng tìm hiểm các tính năng thông dụng nhất của <code>net/http</code></p>
<h3 id="cbnvnethttp">Cơ bản về <code>net/http</code></h3>
<h4 id="httpserverngin">HTTP server đơn giản</h4>
<p>Đầu tiên, sử dụng <code>net/http</code> chúng ta hãy khỏi tạo một server HTTP vô cùng đơn giản</p>
<pre><code class="language-go">// main.go
package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, HelloServer)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    
    if err != nil {
        log.Fatalf(&quot;Error creating server %s\n&quot;, err.Error())
    }
}

func HelloServer(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hello, %s!&quot;, r.URL.Path[1:])
}
</code></pre>
<p>Ở đoạn code trên, chúng ta tạo một http server ở cổng 8080 và dùng hàm <code>http.HandleFunc</code> để  thiết lập thực thi chạy hàm <code>HelloServer</code> mỗi khi có request đến đường dẫn root <code>/</code>. Khi có request gửi đến, <code>HelloServer</code> sẽ được gọi và hai paramerter <code>w</code>(<code>http.ResponseWriter</code>) và <code>r</code>(<code>*http.Request</code>) sẽ được set tương ứng là 2 giá trị đại diện cho response và request của request đó.<br>
Ta sử dụng câu lệnh sau để chạy test thử http server:</p>
<pre><code class="language-sh">go run main.go
</code></pre>
<p>Truy cập vào địa chỉ web <code>http://localhost:8080/handsome/good/boy</code>, ta sẽ thấy đoạn text sau được trả về</p>
<pre><code>Hello, handsome/good/guy!
</code></pre>
<p>Để add thêm các tính năng cho từng đường dẫn, ta đơn giản chỉ cần tiếp tục sử dụng hàm <code>http.HandleFunc</code>:</p>
<pre><code class="language-go">http.handleFunc(&quot;/route1&quot;, Function1)
http.handleFunc(&quot;/route2&quot;, Function2)
</code></pre>
<h4 id="httpclient">HTTP Client</h4>
<p>Ta cũng có thể sử dụng <code>net/http</code> để gửi request HTTP. Sửa đoạn code ở trên để thêm 1 đường dẫn để gọi API thông tin về mèo như sau</p>
<pre><code class="language-go">func main() {
// ...
    http.HandleFunc(&quot;/api/facts&quot;, CatFacts)
// ...
}

// ...
func GetFacts(w http.ResponseWriter, r *http.Request) {
    resp, err := http.Get(&quot;https://cat-fact.herokuapp.com/facts/random?animal_type=cat&amp;amount=29&quot;)
    if err != nil {
        log.Printf(&quot;Error getting data %s&quot;, err.Error())
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        log.Printf(&quot;Error parsing data %s&quot;, err.Error())
    }

    var catFacts []CatFact
    err = json.Unmarshal(body, &amp;catFacts)

    if err != nil {
        log.Printf(&quot;Error parsing json %s&quot;, err.Error())
    }

    w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    err = json.NewEncoder(w).Encode(catFacts)
    if err != nil {
        log.Printf(&quot;Error encoding json %s&quot;, err.Error())
    }
}
</code></pre>
<p>Truy cập vào địa chỉ <code>http://localhost:8080/api/cat</code>, ta sẽ thấy chuỗi json kết quả được trả về (hơi bị vô nghĩa khi gọi API lấy json rồi parse lại thành Go Struct rồi lại trả về json, nhưng vì là code demo nên tất cả đều là ok :D). Ở đoạn code trên ta sử dụng hàm <code>http.Get</code> để gửi request lấy dữ liệu từ api cat-fact. Response trả về là định dạng <code>io.Reader</code> do đó phải dùng hàm <code>ioutil.ReadAll</code> để chuyển sang dạng <code>[]byte</code> rồi parse thành dạng Struct CatFact. Để trả về data dưới định dạng json thì ta cần set Header <code>Content-Type</code> cho response trả về đồng thời ghi dữ liệu muốn trả về vào <code>http.ResponseWriter</code> <code>w</code>.</p>
<pre><code class="language-go">w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
err = json.NewEncoder(w).Encode(catFacts)
</code></pre>
<p><code>net/http</code> hiện giờ chỉ hỗ trợ GET, POST và HEAD tương ứng với các hàm <code>http.Get</code>, <code>http.Post</code>, <code>http.Post</code>. Ngoài ra, để có thể chỉnh sửa các setting cho request ta có thể sử dụng 2 cách tạo request khác:</p>
<ul>
<li>Thay vì dùng trực tiếp các method từ <code>http</code>, khởi tạo một <code>Client</code> object và gọi các method <code>Get</code>, <code>Post</code>, <code>Head</code><pre><code class="language-go">var client = &amp;http.Client{Timeout: 10 * time.Second}
resp, err := client.Get(&quot;...&quot;)
</code></pre>
</li>
<li>Dùng hàm <code>http.NewRequest</code><pre><code class="language-go">var client = &amp;http.Client{}
req, err := http.NewRequest(&quot;GET&quot;, &quot;...&quot;, nil)
req.Header.Add(&quot;If-None-Match&quot;, `W/&quot;wyzzy&quot;`)
resp, err := client.Do(req)
</code></pre>
</li>
</ul>
<h3 id="servermux">ServerMux</h3>
<p>Hầu hết các web framework đều có một thành phần quan trọng là Router để giúp người phát triển có thể thiết kế các đường dẫn trong ứng dụng của mình, mapping các đường dẫn tới các hàm thực thi trong ứng dụng. Có rất nhiều các http router được viết và opensource cho go, <code>net/http</code>đã đi kèm sẵn với <code>ServerMux</code>, một HTTP request multiplexer, đủ dùng cho việc làm router đơn giản. Việc sử dụng <code>http.HandleFunc</code> cùng với <code>http.ListenAndServe</code> như ở dưới đây thực chất là đã định nghĩa mapping đường dẫn cho <code>DefaultServerMux</code>, một <code>ServerMux</code> mặc định.</p>
<pre><code class="language-go">http.HandleFunc(&quot;/&quot;, HelloServer)
err := http.ListenAndServe(&quot;:8080&quot;, nil)
</code></pre>
<p>Tuy nhiên đây là <code>ServerMux</code> global có thể được access trong toàn bộ ứng dụng nên có thể xảy ra các vấn đề về security nên tốt nhất ta nên tạo riêng 1 <code>ServerMux</code>ở local scope và dùng riêng.</p>
<pre><code class="language-go">//...
mux := http.NewServeMux()
mux.HandleFunc(&quot;/&quot;, HelloServer)
mux.HandleFunc(&quot;/api/facts&quot;, GetFacts)
err := http.ListenAndServe(&quot;:8080&quot;, mux)
//...
</code></pre>
<p>Vì bản chất của <code>ServerMux</code> chỉ là một HTTP request multiplexer nên tính năng của <code>ServerMux</code> khá là hạn chế. Với các đường dẫn kết thúc bằng <code>/</code> ví dụ <code>/home/</code> thì <code>ServerMux</code> sẽ match tất cả những đường dẫn con như là <code>/home/sweet</code> hay <code>/home/sweet/home</code>. Do vậy với http server ở trên của chúng ta, khi truy cập vào <code>/home/sweet/home</code> thì hàm <code>HelloServer</code> cũng được gọi. Còn nếu đường dẫn không kết thúc bằng <code>/</code> thì chỉ khi nào đường dẫn match đúng thì hàm handler mới được gọi. Ngoài ra, <code>ServerMux</code> cũng không support wildcat matching, matching theo method của Request, tự động lấy parameter từ đường dẫn. Nếu muốn làm những việc trên thì đều phải code bằng tay. Ví dụ như sau:</p>
<ul>
<li>Giới hạn chỉ xử lý GET request<pre><code class="language-go">func HelloServer(w http.ResponseWriter, r *http.Request) {
    if r.Method != &quot;GET&quot; {
        w.Header().Set(&quot;Allow&quot;, &quot;GET&quot;)
        http.Error(w, &quot;Method Not Allowed&quot;, 405)
        return
    }
    fmt.Fprintf(w, &quot;Hello, %s!&quot;, r.URL.Path[1:]
}
</code></pre>
</li>
<li>Đọc query parameter từ đường dẫn<pre><code class="language-go">//...
func GetFacts(w http.ResponseWriter, r *http.Request) {
    if r.Method != &quot;GET&quot; {
        w.Header().Set(&quot;Allow&quot;, &quot;GET&quot;)
        http.Error(w, &quot;Method Not Allowed&quot;, 405)
        return
    }

    animalType := r.URL.Query().Get(&quot;animal_type&quot;)
    if animalType == &quot;&quot; {
        animalType = &quot;cat&quot;
    }

    amount, err := strconv.Atoi(r.URL.Query().Get(&quot;amount&quot;))
    if err != nil {
      amount = 29
    }

    resp, err := http.Get(fmt.Sprintf(&quot;https://cat-fact.herokuapp.com/facts/random?animal_type=%s&amp;amount=%d&quot;, animalType, amount))
      //...
}
</code></pre>
</li>
</ul>
<p>Có thể thấy ta nên chỉ dùng <code>ServeMux</code> cho những ứng dụng web đơn giản với số đường dẫn ít, với những ứng dụng đòi hỏi đường dẫn phức tạp hay REST API thì ta nên sử dụng một trong rất nhiều những router bên thứ ba với đầy đủ tính năng hơn.</p>
<h3 id="ktlun">Kết luận</h3>
<p>Bài viết này đã giới thiệu qua những tính năng cơ bản nhất của package <code>net/http</code>. Ở bài viết sau ta sẽ cùng tìm hiểu các tính năng nâng cao hơn làm nên sức mạnh của <code>net/http</code> như middleware, context,..</p>
<h3 id="thamkho">Tham khảo</h3>
<ul>
<li><a href="https://golang.org/pkg/net/http/">https://golang.org/pkg/net/http/</a></li>
</ul>
<!--kg-card-end: markdown--><p></p><p></p>]]></content:encoded></item><item><title><![CDATA[Tạo cuộc gọi tự động với Twilio bằng PHP]]></title><description><![CDATA[<!--kg-card-begin: markdown--><h3 id="1giithiu">|1| Giới thiệu</h3>
<p>Twilio là dịch vụ cho phép bạn xây dựng ứng dụng liên quan đến việc gửi và nhận các tin nhắn và cuộc gọi trên điện thoại một cách tự động.<br>
Bài viết này sẽ demo cách tạo cuộc gọi tự động đến số điện thoại của</p>]]></description><link>https://blog.vietnamlab.vn/tao-cuoc-goi-tu-dong-voi-twilio-bang-php/</link><guid isPermaLink="false">5f295174f7370d0001b81477</guid><category><![CDATA[twilio]]></category><category><![CDATA[php]]></category><category><![CDATA[gather]]></category><dc:creator><![CDATA[D.T.H.L]]></dc:creator><pubDate>Fri, 09 Oct 2020 23:57:07 GMT</pubDate><media:content url="https://drive.google.com/uc?id=17G2Yykd9bOH-bYe0v1DinqZuEt_iLa1B&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><h3 id="1giithiu">|1| Giới thiệu</h3>
<img src="https://drive.google.com/uc?id=17G2Yykd9bOH-bYe0v1DinqZuEt_iLa1B&export=download" alt="Tạo cuộc gọi tự động với Twilio bằng PHP"><p>Twilio là dịch vụ cho phép bạn xây dựng ứng dụng liên quan đến việc gửi và nhận các tin nhắn và cuộc gọi trên điện thoại một cách tự động.<br>
Bài viết này sẽ demo cách tạo cuộc gọi tự động đến số điện thoại của khách hàng bằng PHP. Sau khi khách hàng nhận cuộc gọi, sẽ nghe thông tin và lựa chọn các options bằng cách nhấn số 1 hoặc 2 hoặc 3 (tuỳ vào bạn setup).</p>
<h3 id="2totikhontwiliodngth">|2| Tạo tài khoản Twilio dùng thử</h3>
<p>Bạn vào trang <a href="https://www.twilio.com">https://www.twilio.com</a> và đang ký một tài khoản. Sau đó sẽ vào màn hình console <a href="https://www.twilio.com/console">https://www.twilio.com/console</a>. Tại đây bạn đăng ký để được được cấp một số điện thoại trial với tài khoản $15. Bạn sẽ setup số điện thoại này để gọi đến số của khách hàng.</p>
<p><img src="https://drive.google.com/uc?id=11wZY5pbaLhhFOjJCGRQ75km3QPQ0L7tQ&amp;export=download" alt="Tạo cuộc gọi tự động với Twilio bằng PHP"></p>
<p>Như hình trên, bạn sẽ có 3 thông tin cần thiết cho việc setup TRIAL NUMBER, ACCOUNT SID, AUTH TOKEN.</p>
<p>Bạn cũng đừng quên kiểm tra xem giới hạn khu vực ở Việt Nam đã được check chưa. Kiểm tra và check ở <a href="https://www.twilio.com/console/voice/calls/geo-permissions/low-risk">https://www.twilio.com/console/voice/calls/geo-permissions/low-risk</a></p>
<p><img src="https://drive.google.com/uc?id=17pjEvNNKK6_HhYxqF7KQbRe_n9XTncCF&amp;export=download" alt="Tạo cuộc gọi tự động với Twilio bằng PHP"></p>
<h3 id="3codeviphp">|3| Code với PHP</h3>
<p>Chương trình của chúng ta ở đây là sẽ gọi điện đến số của khách hàng, sau đó chờ input trả về từ khách hàng. Nó sẽ có những bước sau:</p>
<ol>
<li>Gọi đến khách hàng và phát thông tin.</li>
<li>Chờ nhận input trả về từ khách hàng.</li>
<li>Nếu khách không input gì thì lặp lại câu phát thông tin ở bước 1.</li>
<li>Nếu khách đã input thì cám ơn rồi thoát.</li>
</ol>
<p>Ở bước 2, việc chờ input từ khách thì ta sẽ sử dụng module Gather mà Twilio cung cấp. Tham khảo <a href="https://www.twilio.com/docs/voice/twiml/gather">tại đây</a></p>
<h5 id="citwiliosdk">① Cài Twilio SDK</h5>
<pre><code>composer require twilio/sdk
</code></pre>
<h5 id="cingrok">② Cài ngrok</h5>
<p><code>Ngrok</code> là một dịch vụ xịn xò dùng để public ip local. Có thể tham khảo thêm <a href="https://www.twilio.com/docs/usage/tutorials/how-to-set-up-your-php-development-environment#install-ngrok">tại đây</a>.</p>
<p>Sau khi download về, bạn mở CMD di chuyển vào thư mục chứa file ngrok vừa down về và chạy lệnh sau:</p>
<pre><code class="language-bash">ngrok http 3000
</code></pre>
<p>3000 là port bạn đang mở ở local khi chạy ứng dụng php của bạn (localhost:3000)</p>
<p>Sau khi chạy lệnh trên xong, <code>ngrok</code> sẽ tạo cho bạn 1 link mới. Link này tương đương vs <a href="http://localhost:3000">http://localhost:3000</a>. Bạn sẽ dùng link đó để sử dụng trong twilio.</p>
<p><img src="https://drive.google.com/uc?id=1cwD1gn5J_s8Y78EnQ8rmSjNMGXqANpfw&amp;export=download" alt="Tạo cuộc gọi tự động với Twilio bằng PHP"></p>
<h5 id="tofile1outboundcallphpkchhotcucgi">③ Tạo file 1-outbound-call.php để kích hoạt cuộc gọi</h5>
<pre><code class="language-php">&lt;?php
require_once '/path/to/vendor/autoload.php'; // Loads the library
use Twilio\Rest\Client;

const SERVICE_SSL_URL = &quot;http://70a04428.ngrok.io&quot;

$sid    = &quot;YOU_ACCOUNT_SID&quot;;
$token  = &quot;YOUR_AUTH_TOKEN&quot;;
$client = new Client($sid, $token);

$to     = &quot;+84901234567&quot;;    // YOUR CUSTOMER'S NUMBER
$from   = &quot;+12029463870&quot;;  // TRIAL NUMBER
$params = [
            'url' =&gt; SERVICE_SSL_URL.'/2-call-answered-gather.php'
        ];

$call = $client-&gt;calls-&gt;create($to, $from, $params);

</code></pre>
<p>Sau khi <code>create()</code> được thực thi, dịch vụ Twilio sẽ được kích hoạt. Twilio sẽ gọi lại đường dẫn url mà bạn đã khai báo bên trên để lấy thông tin sẽ phát thoại.</p>
<h5 id="tofile2callansweredgatherphp">④ Tạo file 2-call-answered-gather.php</h5>
<pre><code class="language-php">&lt;?php
require_once '/path/to/vendor/autoload.php';
use Twilio\Twiml;

const SERVICE_SSL_URL = &quot;http://70a04428.ngrok.io&quot;

// Use the Twilio PHP SDK to build an XML response
$response = new Twiml();

// Use the &lt;Gather&gt; verb to collect user input
$params = [
            'method' =&gt; 'POST',
            'numDigits' =&gt; 1,  // limit number input
            'action' =&gt; SERVICE_SSL_URL.'/3-gather.php' // called after input
        ];
$gather = $response-&gt;gather($params);

// use the &lt;Say&gt; verb to request input from the user
$gather-&gt;say('Press 1 to take a survey. Press 2 to hear a joke.');

// If the user doesn't enter input, loop
$response-&gt;redirect(SERVICE_SSL_URL.'/2-call-answered-gather.php');

// Render the response as XML in reply to the webhook request
header('Content-Type: text/xml');
echo $response;
</code></pre>
<p>Sau khi câu lệnh <code>$gather-&gt;say(...)</code> được thực hiện, thì khách hàng sẽ nghe lời thoại bạn đã định nghĩa và dừng chờ khách hàng nhập số. Nếu khách nhập số thì ngay lập tức sẽ được chuyển đến file dưới đây để xử lý. Nếu khách không input gì thì sẽ nhảy xuống câu lệnh bên dưới là lệnh <code>$response-&gt;redirect()</code></p>
<h5 id="tofile3gatherphpxlinputtuser">⑤ Tạo file 3-gather.php để xử lý input từ user</h5>
<pre><code class="language-php">&lt;?php
require_once '/path/to/vendor/autoload.php';
use Twilio\Twiml;

const SERVICE_SSL_URL = &quot;http://70a04428.ngrok.io&quot;

// Use the Twilio PHP SDK to build an XML response
$response = new Twiml();

// If the user entered digits, process their request
if (array_key_exists('Digits', $_POST)) {
    switch ($_POST['Digits']) {
    case 1:
        $response-&gt;say('You selected to take the survey. Thank you!');
        break;
    case 2:
        $response-&gt;say('You selected to her a joke! Why did the robot cross the road? Because it was carbon bonded to the chicken!');
        break;
    default:
        $response-&gt;say('Sorry, I don\'t understand that choice.');
        $response-&gt;redirect(SERVICE_SSL_URL.'/2-call-answered-gather.php');
    }
} else {
    // If no input was sent, redirect to the /voice route
    $response-&gt;redirect(SERVICE_SSL_URL.'/2-call-answered-gather.php');
}

// Render the response as XML in reply to the webhook request
header('Content-Type: text/xml');
echo $response;
</code></pre>
<p>Ở bước này, Twilio sẽ trả về thông tin khách hàng đã input qua <code>Digits</code>. Dữ liệu response theo phương thức <code>POST</code> là do ở bước thứ 4 ta đã định nghĩa <code>method</code> là <code>POST</code>. Bây giờ bạn đã có con số mà khách hàng input, lúc này bạn sẽ xử lý tuỳ vào chương trình của bạn.</p>
<p>Vậy quy trình thực thi giữa app của bạn vs Twilio là như thế nào?</p>
<ol>
<li>Từ app kích hoạt cuộc gọi đến dịch vụ Twilio. Twilio thực hiện cuộc gọi đến số điện thoại đã khai báo.</li>
<li>Khách hàng bắt máy.</li>
<li>Twilio redirect về app lấy message (cái mà Twilio sẽ phát thoại cho số điện thoại gọi đi)</li>
<li>App trả lại cho Twilio message</li>
<li>Twilio phát message qua điện thoại cho khách hàng nghe</li>
<li>Twilio chờ khách hàng input.</li>
<li>Khách hàng input.</li>
<li>Twilio gửi về lại cho app.</li>
<li>App xử lý rồi phản hồi Twilio.</li>
<li>Twilio phát thoại tin nhắn mà app đã phản hồi.</li>
<li>Kết thúc.</li>
</ol>
<h3 id="4chtbi">|4| Chốt bài</h3>
<p>Demo nho nhỏ đã được hoàn thành. Twilio còn cung cấp các tính năng xịn xò khác như đa ngôn ngữ, giọng nam/nữ, v.v... Các bạn tham khảo thêm trên trang document của Twilio nhé.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Rộn ràng đón tết trung thu 2020]]></title><description><![CDATA[<p>Từ ngày xưa xửa xừa xưa,  Việt Nam ta đã có "Tết trung thu" hay còn gọi là "Tết thiếu nhi", "Tết trông trăng" diễn ra vào Rằm tháng Tám âm lịch, là ngày trăng tròn và sáng nhất trong năm. Vào ngày này ai cũng mong muốn được trở</p>]]></description><link>https://blog.vietnamlab.vn/untitled-9/</link><guid isPermaLink="false">5f685237f7370d0001b814e0</guid><category><![CDATA[news]]></category><category><![CDATA[Tin tức]]></category><category><![CDATA[vnlab]]></category><dc:creator><![CDATA[V.H.V]]></dc:creator><pubDate>Fri, 25 Sep 2020 04:35:00 GMT</pubDate><media:content url="https://drive.google.com/uc?id=19caFAeGojP08PERt9NhyH-tZln5o1dyt&amp;export=download" medium="image"/><content:encoded><![CDATA[<img src="https://drive.google.com/uc?id=19caFAeGojP08PERt9NhyH-tZln5o1dyt&export=download" alt="Rộn ràng đón tết trung thu 2020"><p>Từ ngày xưa xửa xừa xưa,  Việt Nam ta đã có "Tết trung thu" hay còn gọi là "Tết thiếu nhi", "Tết trông trăng" diễn ra vào Rằm tháng Tám âm lịch, là ngày trăng tròn và sáng nhất trong năm. Vào ngày này ai cũng mong muốn được trở về bên gia đình, được quây quần bên nhau, cùng chia sẻ những tâm sự, thưởng thức những miếng bánh trung thu thật nghĩa tình và ấm áp. Còn gì quý hơn những giây phút đó khi được về bên gia đình, được nhìn những đứa trẻ nô đùa khắp sân nhà với những chiếc đèn lồng lấp lánh, mọi hình ảnh tuổi thơ được hiện về.</p><p>Vào ngày tết trung thu thời xưa, trẻ em được người lớn tặng cho các loại đèn ông sao, đèn cù, đèn thỏ, đèn kéo quân và các loại đồ chơi trung thu. Vào đêm rằm, trong tiếng trống rộn rã, các bạn nhỏ cầm những chiếc đèn trung thu lung linh sắc màu cùng nhau rước đèn dưới trăng. Để các bé thêm phần hứng khởi, tăng thêm niềm vui trong dịp Tết trung thu, công ty chúng tôi đã gửi tới các bé những phần quà nhỏ xinh. Các bé sẽ được bố mẹ ( hoặc tự mình) chọn cho những món quà yêu thích, phù hợp với lứa tuổi trong "siêu thị" quà tặng của công ty.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1JvWWaf0bhwDn6lC6yL_L2tAx0cPVv4fW&amp;export=download" class="kg-image" alt="Rộn ràng đón tết trung thu 2020"></figure><!--kg-card-begin: html--><p style="text-align: center;font-style:italic; margin-top: 0px; margin-bottom: 20px;">Các bé tha hồ chọn lựa đồ chơi yêu thích </p><!--kg-card-end: html--><p>Tết trung thu nhất định phải ngồi nhâm nhi một chiếc bánh nướng đặc trưng với tách trà nóng bên gia đình. Một đêm đón rằm tháng 8 Âm lịch sẽ chẳng trọn vẹn nếu thiếu bánh trung thu. Từ thời xa xưa, chiếc bánh này đã được xem như linh hồn của đêm trăng tròn nhất trong tháng 8 Âm lịch. Ngày xưa thì bánh nướng chỉ có 1 loại nhân là nhân thập cẩm truyền thống, nhưng ngày nay, để phù hợp với thị hiếu của khách hàng và khẩu vị của tất cả mọi người thì ngày càng có nhiều loại nhân bánh được ra đời.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1LBGQ5CHf4o_R7JCDB1BmrXpIAjT5f_Nr&amp;export=download" class="kg-image" alt="Rộn ràng đón tết trung thu 2020"></figure><p>Ngoài những phần quà cho các bé, công ty cũng gửi tới mỗi nhân viên 1 hộp bánh trung thu thay lời tri ân, tuy là món quà nhỏ nhưng đầy ý nghĩa. </p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1R3hdlDu2MpzxWrYBjk3tmTOdytN6hilP&amp;export=download" class="kg-image" alt="Rộn ràng đón tết trung thu 2020"></figure><!--kg-card-begin: html--><p style="text-align: center;font-style:italic; margin-top: 0px; margin-bottom: 20px;">""Đầu cầu" Hồ Chí Minh </p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1_19Mun7sK0ldPV0F77t6lg1dqgP_GsIQ&amp;export=download" class="kg-image" alt="Rộn ràng đón tết trung thu 2020"></figure><!--kg-card-begin: html--><p style="text-align: center;font-style:italic; margin-top: 0px; margin-bottom: 20px;">"Chị Hằng" đầu cầu HN chuẩn bị phát quà</p><!--kg-card-end: html--><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1r7gspfCYB-s1FlUljp_5GvWusA8hw201&amp;export=download" class="kg-image" alt="Rộn ràng đón tết trung thu 2020"></figure><!--kg-card-begin: html--><p style="text-align: center;font-style:italic; margin-top: 0px; margin-bottom: 20px;">Đầu cầu Đà Nẵng mến thương</p><!--kg-card-end: html--><p>Trung thu ngày xưa với ngày nay vốn đã có quá nhiều khác biệt, ấy vậy mà năm 2020 lại là khoảng thời gian nhân loại chịu nhiều ảnh hưởng nặng nề của dịch bệnh covid-19 nên đêm rằm tháng 8 âm lịch nhất định sẽ thay đổi rất nhiều. Tuy nhiên, dù khác biệt ra sao, Tết trung thu vẫn là ngày đoàn viên của mọi người Việt, cũng như là dịp để trẻ em trên khắp mọi miền đất nước cùng hòa chung không khí nhộn nhịp, tươi vui và ấm áp của đêm trăng rằm. </p>]]></content:encoded></item><item><title><![CDATA[Giới thiệu BERT và ứng dụng vào bài toán phân loại văn bản]]></title><description><![CDATA[<!--kg-card-begin: markdown--><p>Nếu là một người quan tâm tới Deep Learning, chắc hẳn bạn đã từng nghe tới BERT - thứ được nhắc tới liên tục trong vòng 1-2 năm trở lại đây.</p>
<p>Vào cuối năm 2018, các nhà nghiên cứu tại Google AI Language đã công bố mã nguồn mở cho</p>]]></description><link>https://blog.vietnamlab.vn/gioi-thieu-bert-va-ung-dung-vao-bai-toan-phan-loai-van-ban/</link><guid isPermaLink="false">5f39e549f7370d0001b8149a</guid><category><![CDATA[NLP]]></category><category><![CDATA[BERT]]></category><category><![CDATA[PyTorch]]></category><category><![CDATA[machine learning]]></category><dc:creator><![CDATA[N.V.T]]></dc:creator><pubDate>Thu, 17 Sep 2020 07:11:31 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><p>Nếu là một người quan tâm tới Deep Learning, chắc hẳn bạn đã từng nghe tới BERT - thứ được nhắc tới liên tục trong vòng 1-2 năm trở lại đây.</p>
<p>Vào cuối năm 2018, các nhà nghiên cứu tại Google AI Language đã công bố mã nguồn mở cho một kỹ thuật mới trong Natural Language Processing (NLP), được gọi là BERT (Bidirectional Encoder Representations from Transformers). Với khả năng của mình, BERT được coi là một bước đột phá lớn và gây được tiếng vang trong cộng đồng Deep Learning. BERT là gì, tại sao BERT lại tuyệt vời đến vậy, cách sử dụng BERT cho các bài toán NLP, tất cả sẽ được nhắc tới trong bài viết này.</p>
<h3 id="bert">BERT</h3>
<ol>
<li>
<p>BERT là gì</p>
<p>BERT (Bidirectional Encoder Representations from Transformers) là một mô hình ngôn ngữ (Language Model) được tạo ra bởi Google AI. BERT được coi như là đột phá lớn trong Machine Learning bởi vì khả năng ứng dụng của nó vào nhiều bài toán NLP khác nhau: Question Answering, Natural Language Inference,... với kết quả rất tốt.</p>
</li>
<li>
<p>Tại sao lại cần BERT</p>
<p>Một trong những thách thức lớn nhất của NLP là vấn đề dữ liệu. Trên internet có hàng tá dữ liệu, nhưng những dữ liệu đó không đồng nhất; mỗi phần của nó chỉ được dùng cho một mục đích riêng biệt, do đó khi giải quyết một bài toán cụ thể, ta cần trích ra một bộ dữ liệu thích hợp cho bài toán của mình, và kết quả là ta chỉ có một lượng rất ít dữ liệu. Nhưng có một nghịch lý là, các mô hình Deep Learning cần lượng dữ liệu rất lớn - lên tới hàng triệu - để có thể cho ra kết quả tốt. Do đó một vấn đề được đặt ra: làm thể nào để tận dụng được nguồn dữ liệu vô cùng lớn có sẵn để giải quyết bài toán của mình. Đó là tiền đề cho một kỹ thuật mới ra đời: <b>Transfer Learning</b>. Với <b>Transfer Learning</b>các mô hình (model) &quot;chung&quot; nhất với tập dữ liệu khổng lồ trên internet (<b>pre-training</b>) được xây dựng và có thể được &quot;tinh chỉnh&quot; (<b>fine-tune</b>) cho các bài toán cụ thể. Nhờ có kỹ thuật này mà kết quả cho các bài toán được cải thiện rõ rệt, không chỉ trong NLP mà còn trong các lĩnh vực khác như Computer Vision,... BERT là một trong những đại diện ưu tú nhất trong <b>Transfer Learning</b> cho NLP, nó gây tiếng vang lớn không chỉ bởi kết quả mang lại trong nhiều bài toán khác nhau, mà còn bởi vì nó hoàn toàn miễn phí, tất cả chúng ta đều có thể sử dụng BERT cho bài toán của mình.</p>
</li>
<li>
<p>Nền tảng của BERT</p>
<p>BERT sử dụng Transformer là một mô hình <b>attention</b> (attention mechanism) học mối tương quan giữa các từ (hoặc 1 phần của từ) trong một văn bản. Transformer gồm có 2 phần chính: Encoder và Decoder, encoder thực hiện đọc dữ liệu đầu vào và decoder đưa ra dự đoán. Ở đây, BERT chỉ sử dụng Encoder.</p>
<p>Khác với các mô hình directional (các mô hình chỉ đọc dữ liệu theo 1 chiều duy nhất - trái→phải, phải→ trái) đọc dữ liệu theo dạng tuần tự, Encoder đọc toàn bộ dữ liệu trong 1 lần, việc này làm cho BERT có khả năng huấn luyện dữ liệu theo cả hai chiều, qua đó mô hình có thể học được ngữ cảnh (context) của từ tốt hơn bằng cách sử dụng những từ xung quanh nó (phải&amp;trái).</p>
  <p align="center">
 <img src="https://drive.google.com/uc?id=1vFCN6yoBChfSTD8N1A1QhUINRFPFGoiu" alt="Mô hình Transformer">
 <sample>Mô hình encoder</sample>
 </p>
<p>Hình trên mô tả nguyên lý hoạt động của Encoder. Theo đó, input đầu vào là một chuỗi các token w<sub>1</sub>, w<sub>2</sub>,...được biểu diễn thành chuỗi các vector trước khi đưa vào trong mạng neural. Output của mô hình là chuỗi ccs vector có kích thước đúng bằng kích thước input. Trong khi huấn luyện mô hình, một thách thức gặp phải là các mô hình directional truyền thống gặp giới hạn khi học ngữ cảnh của từ. Để khắc phục nhược điểm của các mô hình cũ, BERT sử dụng 2 chiến lược training như sau:</p>
<ol>
<li>
<p>Masked LM (MLM)</p>
<p>Trước khi đưa vào BERT, thì 15% số từ trong chuỗi được thay thế bởi token <b>[MASK]</b>, khi đó mô hình sẽ dự đoán từ được thay thế bởi <b>[MASK]</b> với context là các từ không bị thay thế bởi <b>[MASK]</b>. Mask LM gồm các bước xử lý sau :</p>
<ul>
<li>Thêm một classification layer với input là output của Encoder.</li>
<li>Nhân các vector đầu ra với ma trận embedding để đưa chúng về không gian từ vựng (vocabulary dimensional).</li>
<li>Tính toán xác suất của mỗi từ trong tập từ vựng sử dụng hàm softmax.</li>
</ul>
<p>Hàm lỗi (loss function) của BERT chỉ tập trung vào đánh giá các từ được đánh dấu <b>[MASKED]</b> mà bỏ qua những từ còn lại, do đó mô hình hội tụ chậm hơn so với các mô hình directional, nhưng chính điều này giúp cho mô hình hiểu ngữ cảnh tốt hơn.</p>
<p>(Trên thực tế, con số 15% không phải là cố định mà có thể thay đổi theo mục đích của bài toán.)</p>
</li>
<li>
<p>Next Sentence Prediction (NSP)</p>
<p>Trong chiến lược này, thì mô hình sử dụng một cặp câu là dữ liệu đầu vào và dự đoán câu thứ 2 là câu tiếp theo của câu thứ 1 hay không. Trong quá trình huấn luyện, 50% lượng dữ liệu đầu vào là cặp câu trong đó câu thứ 2 thực sự là câu tiếp theo của câu thứ 1, 50% còn lại thì câu thứ 2 được chọn ngẫu nhiên từ tập dữ liệu. Một số nguyên tắc được đưa ra khi xử lý dữ liệu như sau:</p>
<ul>
<li>Chèn token <b>[CLS]</b> vào trước câu đầu tiên và <b>[SEP]</b> vào cuối mỗi câu.</li>
<li>Các token trong từng câu được đánh dấu là A hoặc B.</li>
<li>Chèn thêm vector embedding biểu diễn vị trí của token trong câu (chi tiết về vector embedding này có thể tìm thấy trong bài báo về Transformer).<p align="center">
<img src="https://drive.google.com/uc?id=1eE5phaQY4bPLSpEEAuc9sPia5-auOsLt" alt="NSP">
<sample>Next Sentence Prediction</sample>
</p>
</li>
</ul>
<p>Các bước xử lý trong Next Sentence Prediction:</p>
<ul>
<li>Toàn bộ câu đầu vào được đưa vào Transformer.</li>
<li>Chuyển vector output của <b>[CLS]</b> về kích thước <i>2x1</i> bằng một classification layer.</li>
<li>Tính toán xác suất <i>IsNextSequence</i> bằng softmax.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Phương pháp Fine-tuning BERT</p>
<p>Tùy vào bài toán mà ta có các phương pháp fine-tune khác nhau:</p>
<ol>
<li>Đối với bài toán Classification, ta thêm vào một <b>Classification Layer</b> với input là output của <b>Transformer</b> cho token <b>[CLS]</b>.</li>
<li>Đối với bài toán Question Answering, model nhận dữ liệu input là đoạn văn bản cùng câu hỏi và được huấn luyện để  đánh nhãn cho câu trả lời trong đoạn văn bản đó.</li>
<li>Đối với bài toán Named Entity Recognition (NER), model được huấn luyện để dự đoán nhãn cho mỗi token (tên người, tổ chức, địa danh,...).</li>
</ol>
</li>
</ol>
<h3 id="ngdngbertvophnloivnbn">Ứng dụng BERT vào phân loại văn bản</h3>
<p>Sau khi tìm hiểu về BERT, ta sẽ cùng sử dụng BERT <b>pretrained-model</b> cho bài toán phân loại văn bản (Text Classification). Xin giải thích một chút về Text Classification, Text Classification là một trong những bài toán phổ biến nhất trong NLP, giải quyết nhiều vấn đề thực tế như phân tích ngữ nghĩa, lọc spam, phân loại tin tức... Ở trong bài viết này, ta sẽ sử dụng BERT cho bài toán phân loại tin giả - Fake news detection. Dataset được sử dụng là <a href="https://www.kaggle.com/nopdev/real-and-fake-news-dataset">REAL and FAKE news dataset</a> từ <b>Kaggle</b>.</p>
<p>Ta sử dụng thư viện <a href="https://huggingface.co/transformers/pretrained_models.html">Huggingface</a> là một thư viện cho phép sử dụng các SOTA (state-of-the-art) transformer trên ngôn ngữ Python bằng framework Pytorch. Trước khi bắt tay vào viết code, ta cần cài đặt một số thư viện sau: Pytorch, torchtext, transformer, matplotlib, pandas, numpy, seaborn.<br>
Ngoài Pytorch, BERT còn được cài đặt trên nhiều framework khác như <a href="https://github.com/Separius/BERT-keras">tensorflow</a> và <a href="https://github.com/Separius/BERT-keras">keras</a>.</p>
<ol>
<li>
<p>Tiền xử lý dữ liệu<br>
Trong phần này, ta xử lý dữ liệu từ bộ <b>REAL and FAKE news dataset</b>, mục đích là tách bộ dữ liệu ban đầu thành 3 tập <i>train, validation, test</i>. Ở đây, ta tạo thêm một trường <i>titletext</i> mới bằng cách ghép các trường <i>title</i> và <i>text</i> với nhau.</p>
<pre><code class="language-python"># Libraries
import pandas as pd
from sklearn.model_selection import train_test_split

def trim_string(x):

    x = x.split(maxsplit=first_n_words)
    x = ' '.join(x[:first_n_words])

    return x
# Read raw data
df_raw = pd.read_csv(raw_data_path)

# Prepare columns
df_raw['label'] = (df_raw['label'] == 'FAKE').astype('int')
df_raw['titletext'] = df_raw['title'] + &quot;. &quot; + df_raw['text']
df_raw = df_raw.reindex(columns=['label', 'title', 'text', 'titletext'])

# Drop rows with empty text
df_raw.drop( df_raw[df_raw.text.str.len() &lt; 5].index, inplace=True)

# Trim text and titletext to first_n_words
df_raw['text'] = df_raw['text'].apply(trim_string)
df_raw['titletext'] = df_raw['titletext'].apply(trim_string) 

# Split according to label
df_real = df_raw[df_raw['label'] == 0]
df_fake = df_raw[df_raw['label'] == 1]

# Train-test split
df_real_full_train, df_real_test = train_test_split(df_real, train_size = train_test_ratio, random_state = 1)
df_fake_full_train, df_fake_test = train_test_split(df_fake, train_size = train_test_ratio, random_state = 1)

# Train-valid split
df_real_train, df_real_valid = train_test_split(df_real_full_train, train_size = train_valid_ratio, random_state = 1)
df_fake_train, df_fake_valid = train_test_split(df_fake_full_train, train_size = train_valid_ratio, random_state = 1)

# Concatenate splits of different labels
df_train = pd.concat([df_real_train, df_fake_train], ignore_index=True, sort=False)
df_valid = pd.concat([df_real_valid, df_fake_valid], ignore_index=True, sort=False)
df_test = pd.concat([df_real_test, df_fake_test], ignore_index=True, sort=False)

# Write preprocessed data
df_train.to_csv(destination_folder + '/train.csv', index=False)
df_valid.to_csv(destination_folder + '/valid.csv', index=False)
df_test.to_csv(destination_folder + '/test.csv', index=False)
</code></pre>
</li>
<li>
<p>Khai báo các thư viện cần thiết</p>
<pre><code class="language-python"># Libraries
import matplotlib.pyplot as plt
import pandas as pd
import torch

# Preliminaries
from torchtext.data import Field, TabularDataset, BucketIterator, Iterator

# Models
import torch.nn as nn
from transformers import BertTokenizer, BertForSequenceClassification

# Training
import torch.optim as optim

# Evaluation
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns

</code></pre>
<p>Phần quan trọng nhất ở đây là thư viện transformer, chứa các class <code>BertTokenizer</code>, <code>BertForSequenceClassification</code> để khởi tạo bộ tách từ và mô hình phân loại.</p>
</li>
<li>
<p>Chuẩn bị dữ liệu và xử lý</p>
<pre><code class="language-python">tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')

# Model parameter
MAX_SEQ_LEN = 128
PAD_INDEX = tokenizer.convert_tokens_to_ids(tokenizer.pad_token)
UNK_INDEX = tokenizer.convert_tokens_to_ids(tokenizer.unk_token)

# Fields
label_field = Field(sequential=False, use_vocab=False, batch_first=True, dtype=torch.float)
text_field = Field(use_vocab=False, tokenize=tokenizer.encode, lower=False, include_lengths=False, batch_first=True,
                   fix_length=MAX_SEQ_LEN, pad_token=PAD_INDEX, unk_token=UNK_INDEX)
fields = [('label', label_field), ('title', text_field), ('text', text_field), ('titletext', text_field)]

# Tabular Dataset
train, valid, test = TabularDataset.splits(path=source_folder, train='train.csv', validation='valid.csv',
                                           test='test.csv', format='CSV', fields=fields, skip_header=True)

# Iterator
train_iter = BucketIterator(train, batch_size=16, sort_key=lambda x: len(x.text),
                            device=device, train=True, sort=True, sort_within_batch=True)
valid_iter = BucketIterator(valid, batch_size=16, sort_key=lambda x: len(x.text),
                            device=device, train=True, sort=True, sort_within_batch=True)
test_iter = Iterator(test, batch_size=16, device=device, train=False, shuffle=False, sort=False)
</code></pre>
<p>Ở đây, ta sử dụng mô hình &quot;bert-base-uncased&quot; của <code>BertTokenizer</code>và tạo các trường <i>Text</i> chứa nội dung bài viết và <i>Label</i> chứa nhãn. Chiều dài dữ liệu đầu vào cho BERT sẽ giới hạn ở 128 <i>token</i>.</p>
<p><i>Một điều cần lưu ý ở đây là để sử dụng BERT tokenizer với TorchText, ta cần khai báo <code>use_vocab=False </code> và <code>tokenize=tokenizer.encode</code>. Việc này sẽ giúp cho Torchtext hiểu rằng ta sẽ không xây dựng lại bộ vocabulary từ đầu.</i></p>
</li>
<li>
<p>Xây dựng model</p>
<pre><code class="language-python">class BERT(nn.Module):
    def __init__(self):
        super(BERT, self).__init__()
        options_name = 'bert-base-uncased'
        self.encoder = BertForSequenceClassification.from_pretrained(options_name)
	
    def forward(self, text, label):
        loss, text_fea = self.encoder(text, labels=label)[:2]
        return loss, text_fea
</code></pre>
<p>Source code trong bài viết sử dụng phiên bản <i>bert-base-uncased</i> của BERT, đây là bản được huấn luyện trên bộ dữ liệu tiếng Anh lower-cased (chứa 12 layer, 768-hidden, 12-heads, 110M params). Các phiên bản khác của BERT có thể tìm thấy ở tài liệu của <a href="https://huggingface.co/transformers/pretrained_models.html">Huggingface</a>.</p>
</li>
<li>
<p>Huấn luyện mô hình</p>
<p>Dưới đây là các hàm lưu các tham số của model</p>
<pre><code class="language-python"># Save and Load functions
def save_checkpoint(save_path, model, valid_loss):
    if save_path is None:
        return
    
    state_dict = {
                     'model_state_dict': model.state_dict(),
                     'valid_loss': valid_loss
                 }
    torch.save(state_dict, save_path)
    print(f'Model saved to ==&gt; {save_path}')

def load_checkpoint(load_path, model):
    if load_path is None:
        return
    
    state_dict = torch.load(load_path, map_location=device)
    print(f'Model loaded from &lt;== {load_path}')
    
    model.load_state_dict(state_dict['model_state_dict'])
    return state_dict['valid_loss']

def save_metrics(save_path, train_loss_list, valid_loss_list, global_steps_list):
    if save_path is None:
        return
    
    state_dict = {
                     'train_loss_list': train_loss_list,
                     'valid_loss_list': valid_loss_list,
                     'global_steps_list': global_steps_list
                 }
    torch.save(state_dict, save_path)
    print(f'Model saved to ==&gt; {save_path}')
   
def load_metrics(load_path):
    if load_path is None:
        return
    
    state_dict = torch.load(load_path, map_location=device)
    print(f'Model loaded from &lt;== {load_path}')
    return state_dict['train_loss_list'], state_dict['valid_loss_list'],state_dict['global_steps_list']
</code></pre>
<p>Hàm  huấn luyện mô hình:</p>
<pre><code class="language-python"># Training function
def train(model,
         optimizer,
         criterion=nn.BCELoss(),
         train_loader=train_iter,
         valid_loader=valid_iter,
         num_epochs=5,
         eval_every=len(train_iter)//2,
         file_path=destination_folder,
         best_valid_loss=float('Inf')):
    # initialize running values
    running_loss = 0.0
    valid_running_loss = 0.0
    global_step = 0
    train_loss_list = []
    valid_loss_list = []
    global_steps_list = []
    
    # training loop
    model.train()
    for epoch in range(num_epochs):
        for (labels, title, text, titletext), _ in train_loader:
            labels = labels.type(torch.LongTensor)
            labels = labels.to(device)
            titletext = titletext.type(torch.LongTensor)
            titletext = titletext.to(device)
            output = model(titletext, labels)
            loss, _ = output
            
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            
            # update running values
            running_loss += loss.item()
            global_step +=1 
            
            # evaluation step
            if global_step % eval_every == 5:
                model.eval()
                with torch.no_grad():
                    # validation loop
                    for(labels, title, text, titletext), _ in valid_loader:
                        labels = labels.type(torch.LongTensor)
                        labels = labels.to(device)
                        titletext = titletext.type(torch.LongTensor)
                        titletext = titletext.to(device)
                        output = model(titletext, labels)
                        loss, _ = output
                        
                        valid_running_loss += loss.item()
                # evaluation
                average_train_loss = running_loss / eval_every
                average_valid_loss = valid_running_loss / eval_every
                train_loss_list.append(average_train_loss)
                valid_loss_list.append(average_valid_loss)
                global_steps_list.append(global_step)
                
                # reset running values
                running_loss = 0.0
                valid_running_loss = 0.0
                model.train()
                
                # print progress
                print('Epoch [{}/{}], Step [{}/{}], Train loss: {:.4f}, Valid loss: {:.4f}'
                      .format(epoch + 1, num_epochs, global_step, num_epochs * len(train_loader), average_train_loss, average_valid_loss))
                # checkpoint
                if best_valid_loss &gt; average_valid_loss:
                    best_valid_loss = average_valid_loss
                    save_checkpoint(file_path + '/' + 'model.pt', model, best_valid_loss)
                    save_metrics(file_path + '/' + 'metrics.pt', train_loss_list, valid_loss_list, global_steps_list)
	save_metrics(file_path + '/metrics.pt', train_loss_list, valid_loss_list, global_steps_list)

model = BERT().to(device)
optimizer = optim.Adam(model.parameters(), lr=2e-5)
train(model=model, optimizer=optimizer)
</code></pre>
<p>Do bài toán fake news detection là bài toán phân loại 2 lớp, ta sử dụng <code>BinaryCrossEntropy</code> làm loss function và <code>Sigmoid</code> làm activation function. Trong quá trình huấn luyện, ta đánh giá hiệu năng của mô hình trên tập validation, sau đó lưu lại model mỗi khi <i>validation loss</i> giảm  nhằm giữ lại model tốt nhất. Dưới đây là kết quả huấn luyện model.</p>
 <p align="center">
 <img src="https://drive.google.com/uc?id=1ByazSUZd8Ju_5bE4dKMqCl_5Kz_0E_qO" alt="Training progress">
 <sample>Quá trình huấn luyện model</sample>
 </p>   
 <p align="center">
 <img src="https://drive.google.com/uc?id=1bkIz2JKpIw6TTA6zj1oPeh8KgM7M_cVj" alt="Evaluation">
 <sample>Kết quả đánh giá cho thấy mô hình đạt accuracy 92.73%</sample>
 </p>
</li>
<li>
<p>Kết luận</p>
<p>Thực nghiệm trên cho thấy chỉ với 5 epoch model BERT được fine-tuning đã cho ra kết quả rất tốt và có thể cải thiện hơn nữa, hơn nữa việc cài đặt được thực hiện dễ dàng với thư viện <a href="https://huggingface.co/transformers/pretrained_models.html">Huggingface</a>. Điều này càng cho thấy khả năng ứng dụng rất lớn của BERT trong các bài toán NLP khác. Source code trong bài viết này có thể được tải về tại <a href="https://github.com/thainv0212/bert-tutorial">đây</a>.</p>
</li>
</ol>
<h3 id="ktlun">Kết luận</h3>
<p>BERT thực sự là một bước đột phá lớn của <b>Machine Learning</b> trong lĩnh vực <b>Natural Language Processing</b>. Với <b>Transfer Learning</b>, ta hoàn toàn có thể thực hiện fine-tune mô hình có sẵn của BERT để giải quyết nhiều bài toán khác nhau trong lĩnh vực này. Trong bài viết này, tôi không đi quá sâu về kỹ thuật bên trong BERT mà chỉ trình bày những ý tưởng cơ bản của nó. Tuy nhiên, bạn đọc muốn tìm hiểu sâu hơn hoàn toàn có thể tham khảo trong tài liệu đầy của của BERT, <a href="https://arxiv.org/abs/1810.04805">paper</a> và <a href="https://github.com/google-research/bert">source code</a>. Qua bài viết này, tôi hy vọng giúp các bạn hiểu được ý tưởng của BERT và cách sử dụng BERT cho một bài toán cụ thể, qua đó có thể đưa ra một gợi ý nho nhỏ về hướng đi cho các bạn khi giải quyết một bài toán NLP trong thực tế. Nếu các bạn có góp ý về bài viết hay vấn đề cần thảo luận, xin vui lòng comment phía dưới, tôi sẽ cố gắng trả lời trong thời gian sớm nhất. Xin cảm ơn!</p>
<h3 id="tiliuthamkho">Tài liệu tham khảo</h3>
<ul>
<li><a href="https://arxiv.org/abs/1810.04805">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a></li>
<li><a href="https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html">Open Sourcing BERT: State-of-the-Art Pre-training for Natural Language Processing</a></li>
<li><a href="https://towardsdatascience.com/bert-text-classification-using-pytorch-723dfb8b6b5b">BERT Text Classification Using Pytorch</a></li>
<li><a href="https://huggingface.co/transformers/pretrained_models.html">Huggingface</a></li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Xử lý logging trong Golang]]></title><description><![CDATA[<!--kg-card-begin: markdown--><p>Log là thành phần không thể thiếu trong mỗi ứng dụng. Có log ta mới biết ứng dụng đã và đang hoạt động thế nào, trạng thái ra làm sao, để từ đó ta có thể debug dễ dàng khi xảy ra lỗi. Trong khi các ngôn ngữ thông dịch</p>]]></description><link>https://blog.vietnamlab.vn/xy-ly-logging-trong-golang/</link><guid isPermaLink="false">5f45937bf7370d0001b814b4</guid><category><![CDATA[golang]]></category><category><![CDATA[log]]></category><category><![CDATA[logging]]></category><category><![CDATA[microservice]]></category><dc:creator><![CDATA[T.P.H]]></dc:creator><pubDate>Thu, 17 Sep 2020 07:10:43 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1p5HdWqxU8a2Ofvedti7YvP2lAEya3ZAO&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://drive.google.com/uc?id=1p5HdWqxU8a2Ofvedti7YvP2lAEya3ZAO&export=download" alt="Xử lý logging trong Golang"><p>Log là thành phần không thể thiếu trong mỗi ứng dụng. Có log ta mới biết ứng dụng đã và đang hoạt động thế nào, trạng thái ra làm sao, để từ đó ta có thể debug dễ dàng khi xảy ra lỗi. Trong khi các ngôn ngữ thông dịch cùng các framework đi kèm xử lý logging rất khỏe như PHP-Laravel, Ruby-Rails,... việc xử lý logging trong golang khá rườm rà và mất thời gian để người mới vận dụng nó. Bài viết sau đây sẽ mô tả cách xử lý logging phổ biến trong Golang đi cùng với các thư viện thông dụng</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="1tisaotacnphilognghimtc">1. Tại sao ta cần phải log nghiêm túc</h3>
<ul>
<li><strong>Có thể bạn chưa biết</strong>: Log là gì. Hiểu đơn gian Log là bản nhật ký hoạt động của ứng dụng. Hầu hết hoạt động của ứng dụng nên được xuất ra log (tất nhiên chỉ nên những hoạt động cần thiết thôi chứ tất cả thì cũng làm ứng dụng chạy chậm đi và tốn bộ nhớ). Log ứng dụng thường ở dạng text. Ví dụ: user A đang đăng nhập thì ứng dụng sẽ ghi thêm 1 dòng trong file log rằng: user A đã đăng nhập thành công hay thất bại.</li>
</ul>
<p>Khi ta hiểu được log là gì rồi, tại sao lại phải log có tâm làm gì.<br>
Ta có meme sau:</p>
<p><img src="https://drive.google.com/uc?id=13S8BKAHnZrunlCSSvc_LGn0XqFcWrBUf&amp;export=download" alt="Xử lý logging trong Golang"></p>
<p>Log kiểu như vậy có cũng như ko :v rất phiêu lưu. Vậy độ chi tiết và chính xác của log tỉ lệ nghịch với thời gian bắt bug của bạn. Làm app bất kỳ mà ko có log cũng giống như lúc cháy nhà mà chả biết cháy từ đâu ra.</p>
<p><img src="https://drive.google.com/uc?id=131rtHoVy3Osfp3lrB9g4soc5EO1-GIdd&amp;export=download" alt="Xử lý logging trong Golang"></p>
<p>Thêm nữa, log không chỉ có tác dụng giảm thời gian bắt bug, mà còn giúp ta nhận diện được các vấn đề performance lẫn các lỗ hỗng tiềm năng để cải thiện và vá chúng.</p>
<p>Một dòng log tiêu chuẩn thường có dạng như sau:</p>
<ul>
<li>Timestamp: thời gian xảy ra sự kiện mà sinh ra log.</li>
<li>Log level: mức độ của log. Thường có ít nhất 3 loại: debug - log chỉ hiện thông để gỡ lỗi, info - log chỉ để log ra thông tin hoạt động, error - log đã xảy ra lỗi.</li>
<li>Contextual data: tất cả dữ liệu cần thiết để ta biết sự kiện xảy ra ở đâu và có thể dùng chúng để tái diễn sự kiện</li>
</ul>
<p>Tuy nhiên, không phải cái gì ta cũng được log ra, đặc biệt là các thông tin nhạy cảm như password, dữ liệu riêng tư của khách hàng. Nên lưu ý.</p>
<h3 id="2loggingtronggo">2. Logging trong Go</h3>
<p>Ở go có một thư viện chuẩn tương tự như các ngôn ngữ khác để log một dòng text ra console. Tuy nhiên để log ra được các dòng log tiêu chuẩn:</p>
<pre><code class="language-sh">INFO: 2019/12/09 12:01:06 main.go:26: Starting the application...
INFO: 2019/12/09 12:01:06 main.go:27: Something noteworthy happened
WARNING: 2019/12/09 12:01:06 main.go:28: There is something you should know about
ERROR: 2019/12/09 12:01:06 main.go:29: Something went wrong
</code></pre>
<p>Ta phải lập trình lại từ đầu rất mất thời gian, chưa kể khi cần custom, thêm chi tiết hoặc tái sử dụng lại package lại phải tinh chỉnh riêng nữa, càng tốn thời gian hơn.</p>
<p>Các ngôn ngữ thông dịch thì bộ xử lý logging thường đi kèm riêng với framework, còn go thì không như vậy, bộ logging đi kèm với các framework của nó phải nói là khá cùi. Bởi vậy ta nên sử dụng thư viện logging phổ biến có nhiều star trên github, các bộ đó mới đủ sức mạnh để mà ta custom logging theo ý thích nhưng vẫn đảm tốc độ phát triển.</p>
<p>Package logging phổ biến nhất trong cộng đồng Golang là logrus. Sau đây là cách sử dụng cơ bản của nó.</p>
<h3 id="3logrus">3. Logrus</h3>
<p><img src="https://drive.google.com/uc?id=1OmEPtwWdzs2L2Yuo8U6ambCOc7CbIHZb&amp;export=download" alt="Xử lý logging trong Golang"></p>
<p>Cài logrus khá đơn giản bằng lệnh sau:</p>
<pre><code class="language-sh">go get &quot;github.com/Sirupsen/logrus&quot;
</code></pre>
<p>Logrus hoàn toàn tương thích vậy package log chuẩn của golang, do đó ta có thể thay thế log import ở bất cứ đâu với logrus.</p>
<p>Ví dụ đơn giản sau với logrus với cú pháp y hệt package log chuẩn.</p>
<pre><code class="language-go">package main

import (
  log &quot;github.com/sirupsen/logrus&quot;
)

func main() {
    log.Println(&quot;Hello world!&quot;)
}
</code></pre>
<p>Chạy code này sẽ ra output sau:</p>
<pre><code class="language-sh">INFO[0000] Hello world!
</code></pre>
<p>Rất dễ phải không.</p>
<h4 id="jsonvilogrus">JSON với Logrus</h4>
<p>Logrus sử dụng rất tốt cho các log có cấu trúc, ví dụ như dạng JSON. Để log ở dạng JSON có ưu điểm đó là các service bên ngoài có thể dễ dàng phân tích cú pháp log của chúng ta, và từ đó lấy thông tin 1 cách dễ dàng.</p>
<pre><code class="language-go">package main

import (
    log &quot;github.com/sirupsen/logrus&quot;
)

func main() {
    log.SetFormatter(&amp;log.JSONFormatter{})
    log.WithFields(
        log.Fields{
            &quot;foo&quot;: &quot;foo&quot;,
            &quot;bar&quot;: &quot;bar&quot;,
        },
    ).Info(&quot;Something happened&quot;)
}

</code></pre>
<p>Output:</p>
<pre><code class="language-sh">{&quot;bar&quot;:&quot;bar&quot;,&quot;foo&quot;:&quot;foo&quot;,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Something happened&quot;,&quot;time&quot;:&quot;2019-12-09T15:55:24+01:00&quot;}
</code></pre>
<p>Config và sử dụng cũng rất đơn giản đúng không.</p>
<h4 id="logleveltronglogrus">Log level trong logrus</h4>
<p>Ở logrus đã có sẵn các hàm cho các log level. Logrus mặc định có bảy level: Trace, Debug, Info, Warn, Error, Fatal, và Panic. Mức độ của log ta có thể hiểu như sau:</p>
<pre><code class="language-go">log.Trace(&quot;Something very low level.&quot;)
log.Debug(&quot;Useful debugging information.&quot;)
log.Info(&quot;Something noteworthy happened!&quot;)
log.Warn(&quot;You should probably take a look at this.&quot;)
log.Error(&quot;Something failed but I'm not quitting.&quot;)
// Calls os.Exit(1) after logging
log.Fatal(&quot;Bye.&quot;)
// Calls panic() after logging
log.Panic(&quot;I'm bailing.&quot;)
</code></pre>
<p>Bằng cách setting log level cho một logger, ta có thể nhận diện loại log cần thiết, phân chia chúng ra từng file riêng biệt, cả phân chia theo môi trường nữa, rất thuận tiện cho việc đọc và định vị. Mặc đinh thì logrus sẽ log từ Info trở lên (Warn, Error, Fatal, hoặc Panic).</p>
<pre><code class="language-go">package main

import (
    log &quot;github.com/sirupsen/logrus&quot;
)

func main() {
    log.SetFormatter(&amp;log.JSONFormatter{})

    log.Debug(&quot;Useful debugging information.&quot;)
    log.Info(&quot;Something noteworthy happened!&quot;)
    log.Warn(&quot;You should probably take a look at this.&quot;)
    log.Error(&quot;Something failed but I'm not quitting.&quot;)
}
</code></pre>
<p>Output:</p>
<pre><code class="language-sh">{&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Something noteworthy happened!&quot;,&quot;time&quot;:&quot;2019-12-09T16:18:21+01:00&quot;}
{&quot;level&quot;:&quot;warning&quot;,&quot;msg&quot;:&quot;You should probably take a look at this.&quot;,&quot;time&quot;:&quot;2019-12-09T16:18:21+01:00&quot;}
{&quot;level&quot;:&quot;error&quot;,&quot;msg&quot;:&quot;Something failed but I'm not quitting.&quot;,&quot;time&quot;:&quot;2019-12-09T16:18:21+01:00&quot;}
</code></pre>
<p>Để ý thì log debug sẽ không được in ra. Để in ra nó, ta thay đổi level mặc định của logrus:</p>
<pre><code class="language-go">log.SetLevel(log.DebugLevel)
</code></pre>
<h3 id="4tngkt">4. Tổng kết:</h3>
<p>Ở các ngôn ngữ khác, đặc biệt là ngôn ngữ thông dịch, bạn có thể không gặp vấn đề với log, tuy nhiên với golang thì có đấy. Vì vậy sử dụng thành thạo một log package thông dụng là cần thiết để sử dụng nó ở bất kỳ golang framework nào mà bạn dùng (logrus được hỗ trợ bởi hầu hết các framework của go). Phía trên chỉ là cách sử dụng cơ bản thôi, còn nhiều chức năng cần thiết như xuất log ra file, phân chia log theo filter ra các file riêng biệt,... sẽ có hướng dẫn kỹ hơn ở <a href="https://github.com/sirupsen/logrus">Github logrus</a>. Hy vọng bài viết này sẽ giúp ích cho bạn ở vấn đề nhỏ này khi tiếp cận với golang.</p>
<p>Tham khảo:</p>
<ul>
<li><a href="https://github.com/sirupsen/logrus">Logrus github</a></li>
<li><a href="https://www.honeybadger.io/blog/golang-logging/">Golang-logging</a></li>
</ul>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Type system trong ngôn ngữ Dart]]></title><description><![CDATA[<h3 id="i-l-i-m-u">I. Lời mở đầu</h3><p>Ngôn ngữ Dart kết hợp kết hợp việc kiểm tra kiểu dữ liệu <code>static</code> và kiểu dữ liệu <code>runtime</code> để đảm bảo giá trị của một biến luôn luôn phù hợp với kiểu dữ liệu <code>static</code> của biến đó, điều này đôi khi được gọi bằng</p>]]></description><link>https://blog.vietnamlab.vn/type-system-trong-ngon-ngu-dart/</link><guid isPermaLink="false">5f1e81d8f7370d0001b81446</guid><category><![CDATA[Dart]]></category><dc:creator><![CDATA[H.D.K]]></dc:creator><pubDate>Thu, 17 Sep 2020 07:10:11 GMT</pubDate><media:content url="https://drive.google.com/uc?id=1Y6mrUiVqX7ZY0M8hSCYElSSa2ykF6PnV&amp;export=download" medium="image"/><content:encoded><![CDATA[<h3 id="i-l-i-m-u">I. Lời mở đầu</h3><img src="https://drive.google.com/uc?id=1Y6mrUiVqX7ZY0M8hSCYElSSa2ykF6PnV&export=download" alt="Type system trong ngôn ngữ Dart"><p>Ngôn ngữ Dart kết hợp kết hợp việc kiểm tra kiểu dữ liệu <code>static</code> và kiểu dữ liệu <code>runtime</code> để đảm bảo giá trị của một biến luôn luôn phù hợp với kiểu dữ liệu <code>static</code> của biến đó, điều này đôi khi được gọi bằng thuật ngữ <code>sound typing</code> . Trong ngôn ngữ Dart, về bản chất một biến bắt buộc phải có kiểu dữ liệu, nhưng lập trình viên đôi khi không nhất thiết phải dùng <code>type annotations</code> để chỉ ra kiểu dữ liệu của biến đó vì Dart có thể tự suy luận ra kiểu dữ liệu. Ta gọi kiểu dữ liệu được suy ra đó là <code>type inference</code>.</p><p>Một trong những lợi ích của việc kiểm tra kiểu dữ liệu đó là khả năng phát hiển bug lúc <code>compile time</code> sử dụng <code>static analyzer</code>.</p><!--kg-card-begin: markdown--><pre><code>void printInts(List&lt;int&gt; a) =&gt; print(a);

void main() {
  var list = [];
  list.add(1);
  list.add(&quot;2&quot;);
  printInts(list); 
}
// Unhandled exception: type 'List&lt;dynamic&gt;' is not a subtype of type 'List&lt;int&gt;'
</code></pre>
<!--kg-card-end: markdown--><p>Ở đoạn code phía trên, ta thấy biến <code>list</code> không được chỉ ra kiểu dữ liệu cụ thể nên <code>type inference</code>của nó sẽ là <code>List&lt;dynamic&gt;</code>. Việc add các giá trị <code>1</code> và <code>"2"</code> vào là hoàn toàn hợp lệ. Nhưng đến khi truyền <code>list</code> vào hàm <code>printInts</code> thì sẽ bị lỗi vì hàm <code>printInts</code> trong muốn nhận vào tham số có kiểu dữ liệu là <code>List&lt;int&gt;</code>. Nhưng biến <code>list</code> lại có kiểu dữ liệu là <code>List&lt;dynamic&gt;</code> tức không phải là <code>List&lt;int&gt;</code> và cũng không phải là <code>subtype</code>của <code>List&lt;int&gt;</code>.</p><p>Để sửa lỗi, ta sẽ sử code lại thành như sau:</p><!--kg-card-begin: markdown--><pre><code>void printInts(List&lt;int&gt; a) =&gt; print(a);

void main() {
  var list = &lt;int&gt;[];
  list.add(1);
  list.add(2);
  printInts(list);
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="ii-soundness-l-g-">II. Soundness là gì?</h3><p><code>Soundness</code> là 1 khái niệm nhằm thể hiện rằng mong muốn đảm bảo có chương trình không thể rơi vào trạng thái chứa các giá trị không hợp lệ. Một <code>sound type system</code> có nghĩa là chương trình không bao giờ có trạng thái mà chứ một giá trị không phù hợp với <code>static type</code> của nó. Ví dụ như một <code>expression</code> thể hiện <code>static type</code> của nó là <code>String</code> thì tại thời điểm <code>runtime</code> ta đảm bảo nó chỉ có thể thể vào giá trị là <code>String</code>.</p><p><code>Type system</code> của Dart cũng giống như <code>type system</code> trong các ngôn ngữ như Java, C#, .. chúng là <code>sound</code>. Điều này đảm bảo rằng ta kiểm tra cả dữ liệu kiểu <code>static</code> và kiểu <code>runtime</code>. Ví dụ như việc gán một <code>String</code> cho một <code>int</code> là một <code>compile-time error</code>. </p><h3 id="iii-l-i-ch-c-a-soundness-l-g-">III. Lợi ích của soundness là gì?</h3><!--kg-card-begin: markdown--><ul>
<li>Phát hiện bug liên quan đến kiểu dữ liệu ở thời điểm <code>compile time</code>. Một <code>sound type system</code> bắt buộc code không được mơ hồ về kiểu dữ liệu của nó. Nên một số bug mà có phát hiện ở <code>runtime</code> có thể được phát hiện từ sớm về dễ dàng ở thời điểm <code>compile time</code>.</li>
<li>Code dễ đọc. Code sẽ trở nên dễ đọc vì ta có thể nhìn thấy kiểu dữ liệu của nó là gì.</li>
<li>Code dễ được bảo trì. Khi ta sửa 1 phần code nhỏ. <code>type system</code> cá thể cảnh báo rằng việc thay đổi đó có thể làm ảnh hưởng hoặc hư hại để những phần code khác.</li>
<li>Thuận lợi hơn cho <code>ahead of time (AOT) compilation</code>. Mặc dù <code>AOT compilation</code> vẫn khả thi khi không có kiểu dữ liệu, nhưng phần code được <code>generate</code> ra sẽ không tối ưu bằng code được <code>generate</code> ra khi có kiểu dữ liệu.</li>
</ul>
<!--kg-card-end: markdown--><h3 id="iv-m-t-s-tips-kh-ng-b-l-i-b-c-static-analysis">IV. Một số tips để không bị lỗi ở bước static analysis</h3><!--kg-card-begin: markdown--><ol>
<li>Sử dụng <code>sound return type</code> khi override phương thức:</li>
</ol>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1KTiNR8DlRrxo6w1s3yiKbsOFU-1eUMCn&amp;export=download" class="kg-image" alt="Type system trong ngôn ngữ Dart"></figure><p>Kiểu dữ liệu trả về của phương thức trong <code>subclass</code> phải cùng kiểu hoặc là <code>subtype</code> của phương thức tương ứng trong <code>superclass</code>. Ta xét phương thức <code>getter</code> trong <code>Animal</code> class bên dưới:</p><!--kg-card-begin: markdown--><pre><code>class Animal {
  void chase(Animal a) { ... }
  Animal get parent =&gt; ...
}
</code></pre>
<!--kg-card-end: markdown--><p>Phương thức getter cha trả về một <code>Animal</code>. Trong lớp con <code>HoneyBadger</code>, bạn có thể thay thế kiểu trả về getter bằng <code>HoneyBadger</code> (hoặc bất kỳ kiểu con nào khác của <code>Animal</code>), nhưng không được phép sử dụng loại không liên quan.</p><!--kg-card-begin: markdown--><pre><code>// static analysic: success
class HoneyBadger extends Animal {
  void chase(Animal a) { ... }
  HoneyBadger get parent =&gt; ...
}

// static analysic: error/warning
class HoneyBadger extends Animal {
  void chase(Animal a) { ... }
  Root get parent =&gt; ...
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><ol start="2">
<li>Sử dụng <code>sound parameter  type</code> khi override phương thức:</li>
</ol>
<!--kg-card-end: markdown--><p>Tham số của phương thức được bị <code>overridden</code>  phải có cùng loại hoặc là <code>supertype</code> của tham số tương ứng trong <code>superclass</code>.</p><p>Xét phương thức <code>chase (Animal)</code> bên dưới:</p><!--kg-card-begin: markdown--><pre><code>class Animal {
  void chase(Animal a) { ... }
  Animal get parent =&gt; ...
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><ol start="3">
<li>Không sử dụng <code>dynamic list</code> dưới dạng <code>typed list</code>:</li>
</ol>
<!--kg-card-end: markdown--><p><code>Dynamic list</code> hữu dùng khi bạn muốn có một danh sách với các loại khác nhau trong đó. Tuy nhiên ta không thể sử dụng <code>dynamic list</code> như một <code>typed list</code></p><p>Đoạn code sau tạo một <code>Dynamic list</code> của <code>Dog</code> và gán nó vào danh sách kiểu <code>Cat</code>.</p><!--kg-card-begin: markdown--><pre><code>// static analysic: error/warning
class Cat extends Animal { ... }

class Dog extends Animal { ... }

void main() {
  List&lt;Cat&gt; foo = &lt;dynamic&gt;[Dog()]; // Error
  List&lt;dynamic&gt; bar = &lt;dynamic&gt;[Dog(), Cat()]; // OK
}

</code></pre>
<!--kg-card-end: markdown--><p></p><h3 id="v-runtime-checks">V. Runtime checks</h3><p>Các công cụ kiểm tra kiểu dữ liệu tại thời điểm <code>runtime</code> như <code>Dart VM</code> và <code>dartdevc</code> có thể bắt được lỗi mà <code>analyzer</code> không bắt được.</p><!--kg-card-begin: markdown--><pre><code>// runtime: error
void main() {
  List&lt;Animal&gt; animals = [Dog()];
  List&lt;Cat&gt; cats = animals;
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="vi-type-inference">VI. Type inference</h3><p><code>Analyzer</code>  có thể suy ra các kiểu cho các trường, phương thức, biến cục bộ và hầu hết các <code>generic type argument</code>. Khi <code>analyzer</code> không có đủ thông tin để suy ra một loại cụ thể, nó sẽ sử dụng kiểu <code>dynamic</code>.</p><p>Sau đây là một ví dụ thể hiện cách <code>type inference</code> làm việc với <code>generic</code>. Trong ví dụ này, biến <code>arguments</code> có giá trị là <code>map</code> với key kiểu <code>String</code> và với <code>value</code> có nhiều kiểu khác nhau. Nếu ta ghi ra kiểu dữ liệu, code được viết như bên dưới:</p><!--kg-card-begin: markdown--><pre><code>Map&lt;String, dynamic&gt; arguments = {'argA': 'hello', 'argB': 42};
</code></pre>
<!--kg-card-end: markdown--><p>Trường hợp ta không muốn phải ghi rõ kiểu dữ liệu mà muốn Dart hỗ trợ ta tự suy ra kiểu dữ liệu thì code sẽ như bên dưới:</p><!--kg-card-begin: markdown--><pre><code>var arguments = {'argA': 'hello', 'argB': 42}; // Map&lt;String, Object&gt;
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><ol>
<li>Field and method inference</li>
</ol>
<!--kg-card-end: markdown--><p>Một trường hoặc phương thức không có kiểu dữ liệu được chỉ định cụ thể và <code>override</code> trường hoặc phương thức của class cha sẽ kế thừa kiểu dữ liệu tương ứng từ phương thức hoặc trường của class cha</p><p>Một trường không có loại khai báo hoặc kế thừa nhưng được khai báo với giá trị ban đầu, sẽ có loại được suy ra dựa trên giá trị ban đầu đó.</p><!--kg-card-begin: markdown--><ol start="2">
<li>Static field inference</li>
</ol>
<!--kg-card-end: markdown--><p><code>Static field</code> và biến sẽ nhận kiểu dữ liệu từ <code>initializer</code> của chúng.</p><!--kg-card-begin: markdown--><ol start="3">
<li>Local variable inference</li>
</ol>
<!--kg-card-end: markdown--><p>Kiểu dữ liệu của biến cục bộ được suy ra từ <code>initializer</code> (nếu có). Các phép gán sau đó sẽ không được tính tới. Điều này có nghĩa là nếu như ta biết trước kiểu dữ liệu được suy ra không phù hợp, thì ngay từ đầu ta chỉ định rõ kiểu dữ liệu chứ không phó thác cho Dart làm.</p><!--kg-card-begin: markdown--><pre><code>// static analysic: error/warning
var x = 3; // x is inferred as an int
x = 4.0;

// static analysic: success
num y = 3; // a num can be double or int
y = 4.0;
</code></pre>
<!--kg-card-end: markdown--><p></p><!--kg-card-begin: markdown--><ol start="4">
<li>Type argument inference</li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code>// Inferred as if you wrote &lt;int&gt;[].
List&lt;int&gt; listOfInt = [];

// Inferred as if you wrote &lt;double&gt;[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable&lt;int&gt;
var ints = listOfDouble.map((x) =&gt; x.toInt());
</code></pre>
<!--kg-card-end: markdown--><p>Trong ví dụ trên <code>x</code> có kiểu được suy ra là <code>double</code> và <code>ints</code> có kiểu dữ liệu được suy ra là <code>Iterable&lt;int&gt;</code></p><h3 id="vii-substituting-types">VII. Substituting types</h3><p>Khi <code>override</code> một phương thức, ta thay thế một số thứ (trong phương thức cũ) thành một thứ khác (trong phương thức mới), tương tự như vậy khi ta truyền tham số cho một hàm, ta thay một thứ có kiểu dữ liệu được khai báo trong định nghĩa hàm bằng 1 thứ có kiểu dữ liệu (có thể khác) tương ứng với giá trị của tham số mà ta truyền vào. Câu hỏi là đặt ra là việc thay thế như vậy khi nào đúng khi nào sai? Kiểu dự liệu nào có thể thay thế cho kiểu dữ liệu nào?</p><p>Khi bàn về vấn đề trên, ta thường sẽ sử dụng 2 thuật ngữ là <code>consumer</code> và <code>producer</code>. <code>Consumer</code> là cái mà nhận kiểu dữ liệu và <code>producer</code> là cái mà tạo ra kiểu dữ liệu. Nguyên tắc là ta có thể thay kiểu dữ liệu của <code>comsumer</code> bằng <code>supertype</code> của nó, và có thể thay kiểu dữ liệu của <code>producer</code> bằng <code>subtype</code> của nó.</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1lwHkTjV5Oxdi29NryJI5EYxH-0yYU3K3&amp;export=download" class="kg-image" alt="Type system trong ngôn ngữ Dart"></figure><p>Xét sơ đồ kế thừa bên trên, ta gán 1 phép gán đơn giản như sau:</p><!--kg-card-begin: markdown--><pre><code>Cat c = Cat();
</code></pre>
<!--kg-card-end: markdown--><p><code>c</code> sẽ đóng vai trò là <code>consumer</code> và <code>Cat()</code> đóng vai trò là <code>producer</code>.</p><!--kg-card-begin: markdown--><pre><code>// static analysic: success
Animal c = Cat();
// static analysic: error/warning
MaineCoon c = Cat();
</code></pre>
<!--kg-card-end: markdown--><p>Tương tự ta có ví dụ như bên dưới:</p><figure class="kg-card kg-image-card"><img src="https://drive.google.com/uc?id=1trNVYhvCzlh6E3BEN10PLrUa3F33ZF0j&amp;export=download" class="kg-image" alt="Type system trong ngôn ngữ Dart"></figure><!--kg-card-begin: markdown--><pre><code>// static analysic: success
List&lt;Cat&gt; myCats = List&lt;MaineCoon&gt;();

</code></pre>
<!--kg-card-end: markdown--><p>Chuyện gì sẽ xảy ra nên ta gán <code>List&lt;Animal&gt;</code> cho <code>List&lt;Cat&gt;</code> ?</p><!--kg-card-begin: markdown--><pre><code>// static analysic: success
List&lt;Cat&gt; myCats = List&lt;MaineCoon&gt;();
</code></pre>
<!--kg-card-end: markdown--><p>Ta thấy vẫn pass được <code>static analysic</code> vì nó được dịch thành code như bên dưới:</p><!--kg-card-begin: markdown--><pre><code>List&lt;Cat&gt; myCats = List&lt;Animal&gt;() as List&lt;Cat&gt;;
</code></pre>
<!--kg-card-end: markdown--><p>Tuy nhiên đoạn code trên có thể bị fail tại thời điểm <code>runtime</code>. Để chặn việc ép kiểu ngầm ta có thể setting bằng <code>implicit-casts</code></p><h3 id="viii-ngu-n-tham-kh-o">VIII. Nguồn tham khảo</h3><p><a href="https://dart.dev/guides/language/type-system">https://dart.dev/guides/language/type-system</a></p>]]></content:encoded></item><item><title><![CDATA[Quản lý docker ez với Portainer]]></title><description><![CDATA[<!--kg-card-begin: markdown--><p>Docker, một thứ đã quá quen thuộc với coder ngày nay. Coder đủ thể loại từ backend, frontend tới devops chắc chắn đều đã và đang sử dụng nó. Việc sử dụng  docker sau thời gian thường sinh ra nhiều rác làm tốn nhiều tài nguyên của máy đặc biệt</p>]]></description><link>https://blog.vietnamlab.vn/quan-ly-docker-ez-voi-portainer/</link><guid isPermaLink="false">5f39d943f7370d0001b81494</guid><category><![CDATA[docker]]></category><dc:creator><![CDATA[N.V.T]]></dc:creator><pubDate>Thu, 17 Sep 2020 07:09:21 GMT</pubDate><media:content url="https://drive.google.com/uc?id=14ogLjBABtiz3FOXJxdSglL031PpAbeII&amp;export=download" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://drive.google.com/uc?id=14ogLjBABtiz3FOXJxdSglL031PpAbeII&export=download" alt="Quản lý docker ez với Portainer"><p>Docker, một thứ đã quá quen thuộc với coder ngày nay. Coder đủ thể loại từ backend, frontend tới devops chắc chắn đều đã và đang sử dụng nó. Việc sử dụng  docker sau thời gian thường sinh ra nhiều rác làm tốn nhiều tài nguyên của máy đặc biệt là dung lượng ổ đĩa. Việc dọn dẹp lại docker sẽ được thực hiện thông qua CLI của docker. Tuy nhiên, đối với những coder lâu lâu chỉ làm việc với docker thì việc sử dụng CLI mất khá nhiều thời gian nên việc sử dụng giao diện để quản lý là hiệu quả hơn. Vì vậy ở bài viết này mình sẽ giới thiệu Portainer - một trình quản lý docker chạy trên web.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="cit">Cài đặt</h3>
<p>Bài viết này mình chủ yếu tập trung cho coder sử dụng docker cho môi trường dev local sử dụng hệ điều hành Linux/MacOS.</p>
<p>Việc cài đặt portainer rất đơn giản. Bạn chỉ cần tạo 1 persistent volume để lưu dữ liệu và chạy portainer/portainer container.</p>
<pre><code class="language-sh"># Tạo volume cho portainer
docker volume create portainer_data

# Tạo portainer container
docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>
<p>Tất nhiên là bạn có thể thay đổi <code>-p 9000:9000</code> thành port khác nếu bạn thích.<br>
Sau khi portainer container đã được chạy, truy cập <a href="http://localhost:9000">http://localhost:9000</a> để vào UI của portainer. Ở lần chạy đầu tiên, portainer sẽ yêu cầu bạn tạo người dùng và connect tới docker endpoint. Ở đây mình connect tới local endpoint<br>
<img src="https://drive.google.com/uc?id=1e0aJAhCRXQBopU28DO9WBKY59kKGFWEl&amp;export=download" alt="Quản lý docker ez với Portainer"></p>
<p><img src="https://drive.google.com/uc?id=1_uNkIR8bJCzJpX5_6wb6Llnqnj3LaEbE&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Sau khi connect tới local endpoint<br>
<img src="https://drive.google.com/uc?id=1Zf2LnPk56RpjkI8x3-s1TuvLjOZPP4xy&amp;export=download" alt="Quản lý docker ez với Portainer"></p>
<p>Ngoài ra, Portainer cũng có thể cài đặt cho các môi trường khác cho Windows containers, docker swarm,... bạn có thể tham khảo thêm ở <a href="https://www.portainer.io/installation/">https://www.portainer.io/installation/</a></p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="update">Update</h3>
<p>Việc Update cũng rất đơn giản!!!</p>
<pre><code class="language-sh"># Xoá portainer container
docker rm -f portainer

# Xoá portainer/portainer image
docker image rm portainer/portainer

# Pull latest portainer/portainer image và tạo lại container mới 
docker run -d -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="tnhnng">Tính năng</h3>
<h4 id="chcnngchoquntr">Chức năng cho quản trị</h4>
<ul>
<li>Quản lý user với permission, team và role</li>
<li>Quản lý Docker endpoint:
<ul>
<li>Local endpoint</li>
<li>Docker API endpoint</li>
<li>Portainer agent / Portainer Edge Agent</li>
<li>Azure ACI</li>
</ul>
</li>
<li>Quản lý Docker Registry</li>
</ul>
<h4 id="chcnngqunlendpoint">Chức năng quản lý endpoint</h4>
<p>Ở màn hình home chọn endpoint cần quản lý.<br>
Tổng quan về endpoint:<br>
<img src="https://drive.google.com/uc?id=1J4o4CZeMWC1J9lPufkoYha00CTy4EeFs&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Stacks để quản lý các compose:<br>
<img src="https://drive.google.com/uc?id=17RqMBYh-VOIbZnI6SOlar9Gi-UtjG11j&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Quản lý các container:<br>
<img src="https://drive.google.com/uc?id=1-fYcaZ5JVXBYu2MwEYC1k3L3K0dFtdkN&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Ở đây bạn có thể start, stop, remove, ... và nhiều thứ khác để quản lý container.<br>
Xem log của container:<br>
<img src="https://drive.google.com/uc?id=1phi0k821reGW-2VGL4mqS9AsY3fTPomF&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Monitoring container:<br>
<img src="https://drive.google.com/uc?id=1h37TgtNolfip3LBtb73fdHVnLCDsrYel&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Chạy thẳng lệnh trong container:<br>
<img src="https://drive.google.com/uc?id=10hYmQv9Pjpgf6l0OiNUvHkFzqS6Bu-QQ&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
<img src="https://drive.google.com/uc?id=1itcu6RsoBCoB9t_MbZ9uQ94coblh7WAZ&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Quản lý image:<br>
<img src="https://drive.google.com/uc?id=1eXDueERm11K7K6vyN9yyaBFRbwR0CvRT&amp;export=download" alt="Quản lý docker ez với Portainer"><br>
Quản lý volume:<br>
<img src="https://drive.google.com/uc?id=1UeaD3pRW9RiOi2p-6aLcduC3gUlYz_4l&amp;export=download" alt="Quản lý docker ez với Portainer"></p>
<blockquote>
<p>Giao diện quản lý image, volume rất trực quan, nhìn vào là biết image, volume nào không còn được sử dụng để clean.</p>
</blockquote>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id="ktlun">Kết luận</h3>
<p>Bài viết chỉ giới thiệu qua Portainer với screenshots các tính năng để có cái nhìn tổng quan về Portainer. Nếu bạn thích nó thì hãy cài nó và trải nghiệm hết các tính năng của nó. Thông qua nó bạn có thể hiểu thêm các tính năng của docker mà trước đó bạn có thể chưa biết. :))</p>
<p>Với Portainer việc quản lý docker đã trở nên dễ dàng và trực quan hơn rất nhiều so với việc phải dùng CLI. Đỡ phải nhớ lệnh rồi lại google rất mất thời gian cho coder ít dùng docker. Hy vọng bài viết giúp ích cho các bạn.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item></channel></rss>